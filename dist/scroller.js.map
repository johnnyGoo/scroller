{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///scroller.js","webpack:///webpack/bootstrap d75278c6ecfc38bd8e75","webpack:///./index.js","webpack:///./src/Animate.js","webpack:///./src/Scroller.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Scroller","global","Animate","time","Date","now","desiredFrames","millisecondsPerSecond","running","counter","core","effect","requestAnimationFrame","requestFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","oRequestAnimationFrame","isNative","test","toString","callback","TARGET_FPS","requests","requestCount","rafHandle","intervalHandle","lastActive","callbackHandle","setInterval","currentRequests","key","hasOwnProperty","clearInterval","stop","cleared","isRunning","start","stepCallback","verifyCallback","completedCallback","duration","easingMethod","lastFrame","percent","dropCounter","document","body","newRunning","usedId","step","virtual","render","droppedFrames","Math","round","j","min","value","window","NOOP","options","__callback","scrollingX","scrollingY","animating","animationDuration","bouncing","locking","paging","snapping","zooming","minZoom","maxZoom","speedMultiplier","scrollingComplete","penetrationDeceleration","penetrationAcceleration","easeOutCubic","pos","pow","easeInOutCubic","members","__isSingleTouch","__isTracking","__didDecelerationComplete","__isGesturing","__isDragging","__isDecelerating","__isAnimating","__clientLeft","__clientTop","__clientWidth","__clientHeight","__contentWidth","__contentHeight","__snapWidth","__snapHeight","__refreshHeight","__refreshActive","__refreshActivate","__refreshDeactivate","__refreshStart","__zoomLevel","__scrollLeft","__scrollTop","__maxScrollLeft","__maxScrollTop","__scheduledLeft","__scheduledTop","__scheduledZoom","__lastTouchLeft","__lastTouchTop","__lastTouchMove","__positions","__minDecelerationScrollLeft","__minDecelerationScrollTop","__maxDecelerationScrollLeft","__maxDecelerationScrollTop","__decelerationVelocityX","__decelerationVelocityY","setDimensions","clientWidth","clientHeight","contentWidth","contentHeight","self","__computeScrollMax","scrollTo","setPosition","left","top","setSnapSize","width","height","activatePullToRefresh","activateCallback","deactivateCallback","startCallback","triggerPullToRefresh","__publish","finishPullToRefresh","getValues","zoom","getScrollMax","zoomTo","level","animate","originLeft","originTop","Error","__zoomComplete","oldLevel","max","zoomBy","factor","scrollBy","startLeft","startTop","doMouseZoom","wheelDelta","timeStamp","pageX","pageY","change","doTouchStart","touches","length","valueOf","__interruptedAnimation","currentTouchLeft","currentTouchTop","isSingleTouch","abs","__initialTouchLeft","__initialTouchTop","__zoomLevelStart","__lastScale","__enableScrollX","__enableScrollY","doTouchMove","scale","positions","moveX","moveY","scrollLeft","scrollTop","currentTouchLeftRel","currentTouchTopRel","maxScrollLeft","maxScrollTop","splice","push","minimumTrackingForScroll","minimumTrackingForDrag","distanceX","distanceY","doTouchEnd","endPos","startPos","i","timeOffset","movedLeft","movedTop","minVelocityToStartDeceleration","__startDeceleration","wasAnimating","oldLeft","oldTop","oldZoom","diffLeft","diffTop","diffZoom","verify","completed","renderedFramesPerSecond","animationId","wasFinished","zoomLevel","floor","ceil","__stepThroughDeceleration","minVelocityToKeepDecelerating","shouldContinue","scrollLeftFixed","scrollTopFixed","frictionFactor","scrollOutsideX","scrollOutsideY","prototype"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,UAAAH,GACA,gBAAAC,SACAA,QAAA,SAAAD,IAEAD,EAAA,SAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,SAGAR,EAAA,KDgBM,SAAUL,EAAQD,EAASM,GEtDjCA,EAAQ,GACRS,SAAST,EAAQ,GACjBL,EAAOD,QAAUe,UF4DX,SAAUd,EAAQD,IG9DxB,SAAAgB,GAwBA,QAASC,KACR,GAAIC,GAAOC,KAAKC,KAAO,WACtB,OAAQ,GAAID,OAETE,EAAgB,GAChBC,EAAwB,IACxBC,KACAC,EAAU,CA4Md,OAvMAC,OAASC,WAGTD,KAAKC,OAAOT,SAQXU,sBAAwB,WAGvB,GAAIC,GAAeZ,EAAOW,uBAAyBX,EAAOa,6BAA+Bb,EAAOc,0BAA4Bd,EAAOe,uBAC/HC,IAAaJ,CAMjB,IAJIA,IAAiB,yDAAyDK,KAAKL,EAAaM,cAC/FF,GAAW,GAGRA,EACH,MAAO,UAASG,EAAUrC,GACzB8B,EAAaO,EAAUrC,GAIzB,IAAIsC,GAAa,GACbC,KACAC,EAAe,EACfC,EAAY,EACZC,EAAiB,KACjBC,GAAc,GAAItB,KAEtB,OAAO,UAASgB,EAAUrC,GACzB,GAAI4C,GAAiBH,GAmCrB,OAhCAF,GAASK,GAAkBP,EAC3BG,IAGuB,OAAnBE,IAEHA,EAAiBG,YAAY,WAE5B,GAAIzB,IAAQ,GAAIC,MACZyB,EAAkBP,CAGtBA,MACAC,EAAe,CAEf,KAAI,GAAIO,KAAOD,GACVA,EAAgBE,eAAeD,KAClCD,EAAgBC,GAAK3B,GACrBuB,EAAavB,EAMXA,GAAOuB,EAAa,OACvBM,cAAcP,GACdA,EAAiB,OAGhB,IAAOJ,IAGJM,MAYTM,KAAM,SAASvC,GACd,GAAIwC,GAAyB,MAAf1B,EAAQd,EAKtB,OAJIwC,KACH1B,EAAQd,GAAM,MAGRwC,GAURC,UAAW,SAASzC,GACnB,MAAsB,OAAfc,EAAQd,IAoBhB0C,MAAO,SAASC,EAAcC,EAAgBC,EAAmBC,EAAUC,EAAc1D,GAExF,GAAIqD,GAAQjC,IACRuC,EAAYN,EACZO,EAAU,EACVC,EAAc,EACdlD,EAAKe,GAOT,IALK1B,IACJA,EAAO8D,SAASC,MAIbpD,EAAK,KAAO,EAAG,CAClB,GAAIqD,KACJ,KAAK,GAAIC,KAAUxC,GAClBuC,EAAWC,IAAU,CAEtBxC,GAAUuC,EAIX,GAAIE,GAAO,SAASC,GAGnB,GAAIC,GAASD,KAAY,EAGrB7C,EAAMF,GAGV,KAAKK,EAAQd,IAAQ4C,IAAmBA,EAAe5C,GAItD,MAFAc,GAAQd,GAAM,UACd6C,GAAqBA,EAAkBjC,EAAiBsC,IAAgBvC,EAAM+B,GAAS7B,GAAyBb,GAAI,GAOrH,IAAIyD,EAGH,IAAK,GADDC,GAAgBC,KAAKC,OAAOjD,EAAMqC,IAAcnC,EAAwBD,IAAkB,EACrFiD,EAAI,EAAGA,EAAIF,KAAKG,IAAIJ,EAAe,GAAIG,IAC/CN,GAAK,GACLL,GAMEJ,KACHG,GAAWtC,EAAM+B,GAASI,EACtBG,EAAU,IACbA,EAAU,GAKZ,IAAIc,GAAQhB,EAAeA,EAAaE,GAAWA,CAC9CN,GAAaoB,EAAOpD,EAAK8C,MAAY,GAAqB,IAAZR,IAAkBQ,EAG1DA,IACVT,EAAYrC,EACZK,KAAKC,OAAOT,QAAQU,sBAAsBqC,EAAMlE,KAJhDyB,EAAQd,GAAM,KACd6C,GAAqBA,EAAkBjC,EAAiBsC,IAAgBvC,EAAM+B,GAAS7B,GAAyBb,EAAgB,IAAZiD,GAA6B,MAAZH,IAcvI,OANAhC,GAAQd,IAAM,EAGdgB,KAAKC,OAAOT,QAAQU,sBAAsBqC,EAAMlE,GAGzCW,IAGFO,EAAOS,KAEfgD,OAAOhD,KAAKR,MH0DkBN,KAAKX,EAAU,WAAa,MAAOI,WAG1D,CAED,SAAUH,EAAQD,GI9RxB,GAAIe,IACJ,WACC,GAAI2D,GAAO,YAKX3D,GAAW,SAASoB,EAAUwC,GAG7BvE,KAAKwE,WAAazC,EAElB/B,KAAKuE,SAGJE,YAAY,EAGZC,YAAY,EAGZC,WAAW,EAGXC,kBAAmB,IAGnBC,UAAU,EAGVC,SAAS,EAGTC,QAAQ,EAGRC,UAAU,EAGVC,SAAS,EAGTC,QAAS,GAGTC,QAAS,EAGTC,gBAAiB,EAKjBC,kBAAmBf,EAGVgB,wBAA0B,IAG1BC,wBAA0B,IAIpC,KAAK,GAAI9C,KAAO8B,GACfvE,KAAKuE,QAAQ9B,GAAO8B,EAAQ9B,GAY9B,IAAI+C,GAAe,SAASC,GAC3B,MAAQzB,MAAK0B,IAAKD,EAAM,EAAI,GAAK,GAM9BE,EAAiB,SAASF,GAC7B,OAAKA,GAAO,IAAO,EACX,GAAMzB,KAAK0B,IAAID,EAAK,GAGrB,IAAOzB,KAAK0B,IAAKD,EAAM,EAAI,GAAK,IAIpCG,GASHC,iBAAiB,EAGjBC,cAAc,EAGdC,2BAA2B,EAM3BC,eAAe,EAOfC,cAAc,EAMdC,kBAAkB,EAKlBC,eAAe,EAWfC,aAAc,EAGdC,YAAa,EAGbC,cAAe,EAGfC,eAAgB,EAGhBC,eAAgB,EAGhBC,gBAAiB,EAGjBC,YAAa,IAGbC,aAAc,IAGdC,gBAAiB,KAGjBC,iBAAiB,EAGjBC,kBAAmB,KAGnBC,oBAAqB,KAGrBC,eAAgB,KAGhBC,YAAa,EAGbC,aAAc,EAGdC,YAAa,EAGbC,gBAAiB,EAGjBC,eAAgB,EAGhBC,gBAAiB,EAGjBC,eAAgB,EAGhBC,gBAAiB,EAWjBC,gBAAiB,KAGjBC,eAAgB,KAGhBC,gBAAiB,KAGjBC,YAAa,KAWbC,4BAA6B,KAG7BC,2BAA4B,KAG5BC,4BAA6B,KAG7BC,2BAA4B,KAG5BC,wBAAyB,KAGzBC,wBAAyB,KAoBzBC,cAAe,SAASC,EAAaC,EAAcC,EAAcC,GAEhE,GAAIC,GAAOxI,IAGPoI,MAAiBA,IACpBI,EAAKlC,cAAgB8B,GAGlBC,KAAkBA,IACrBG,EAAKjC,eAAiB8B,GAGnBC,KAAkBA,IACrBE,EAAKhC,eAAiB8B,GAGnBC,KAAmBA,IACtBC,EAAK/B,gBAAkB8B,GAIxBC,EAAKC,qBAGLD,EAAKE,SAASF,EAAKtB,aAAcsB,EAAKrB,aAAa,IAWpDwB,YAAa,SAASC,EAAMC,GAE3B,GAAIL,GAAOxI,IAEXwI,GAAKpC,aAAewC,GAAQ,EAC5BJ,EAAKnC,YAAcwC,GAAO,GAW3BC,YAAa,SAASC,EAAOC,GAE5B,GAAIR,GAAOxI,IAEXwI,GAAK9B,YAAcqC,EACnBP,EAAK7B,aAAeqC,GAerBC,sBAAuB,SAASD,EAAQE,EAAkBC,EAAoBC,GAE7E,GAAIZ,GAAOxI,IAEXwI,GAAK5B,gBAAkBoC,EACvBR,EAAK1B,kBAAoBoC,EACzBV,EAAKzB,oBAAsBoC,EAC3BX,EAAKxB,eAAiBoC,GAQvBC,qBAAsB,WAGrBrJ,KAAKsJ,UAAUtJ,KAAKkH,cAAelH,KAAK4G,gBAAiB5G,KAAKiH,aAAa,GAEvEjH,KAAKgH,gBACRhH,KAAKgH,kBAQPuC,oBAAqB,WAEpB,GAAIf,GAAOxI,IAEXwI,GAAK3B,iBAAkB,EACnB2B,EAAKzB,qBACRyB,EAAKzB,sBAGNyB,EAAKE,SAASF,EAAKtB,aAAcsB,EAAKrB,aAAa,IAUpDqC,UAAW,WAEV,GAAIhB,GAAOxI,IAEX,QACC4I,KAAMJ,EAAKtB,aACX2B,IAAKL,EAAKrB,YACVsC,KAAMjB,EAAKvB,cAWbyC,aAAc,WAEb,GAAIlB,GAAOxI,IAEX,QACC4I,KAAMJ,EAAKpB,gBACXyB,IAAKL,EAAKnB,iBAgBZsC,OAAQ,SAASC,EAAOC,EAASC,EAAYC,EAAWhI,GAEvD,GAAIyG,GAAOxI,IAEX,KAAKwI,EAAKjE,QAAQU,QACjB,KAAM,IAAI+E,OAAM,0BAIdjI,KACFyG,EAAKyB,eAAiBlI,GAInByG,EAAKtC,mBACR7E,KAAKC,OAAOT,QAAQ+B,KAAK4F,EAAKtC,kBAC9BsC,EAAKtC,kBAAmB,EAGzB,IAAIgE,GAAW1B,EAAKvB,WAGF,OAAd6C,IACHA,EAAatB,EAAKlC,cAAgB,GAGlB,MAAbyD,IACHA,EAAYvB,EAAKjC,eAAiB,GAInCqD,EAAQ5F,KAAKmG,IAAInG,KAAKG,IAAIyF,EAAOpB,EAAKjE,QAAQY,SAAUqD,EAAKjE,QAAQW,SAGrEsD,EAAKC,mBAAmBmB,EAGxB,IAAIhB,IAASkB,EAAatB,EAAKtB,cAAgB0C,EAAQM,EAAYJ,EAC/DjB,GAAQkB,EAAYvB,EAAKrB,aAAeyC,EAAQM,EAAYH,CAG5DnB,GAAOJ,EAAKpB,gBACfwB,EAAOJ,EAAKpB,gBACFwB,EAAO,IACjBA,EAAO,GAIJC,EAAML,EAAKnB,eACdwB,EAAML,EAAKnB,eACDwB,EAAM,IAChBA,EAAM,GAIPL,EAAKc,UAAUV,EAAMC,EAAKe,EAAOC,IAclCO,OAAQ,SAASC,EAAQR,EAASC,EAAYC,EAAWhI,GAExD,GAAIyG,GAAOxI,IAEXwI,GAAKmB,OAAOnB,EAAKvB,YAAcoD,EAAQR,EAASC,EAAYC,EAAWhI,IAaxE2G,SAAU,SAASE,EAAMC,EAAKgB,EAASJ,GAEtC,GAAIjB,GAAOxI,IASX,IANIwI,EAAKtC,mBACR7E,KAAKC,OAAOT,QAAQ+B,KAAK4F,EAAKtC,kBAC9BsC,EAAKtC,kBAAmB,GAIb,MAARuD,GAAgBA,IAASjB,EAAKvB,YAAa,CAE9C,IAAKuB,EAAKjE,QAAQU,QACjB,KAAM,IAAI+E,OAAM,0BAGjBpB,IAAQa,EACRZ,GAAOY,EAGPjB,EAAKC,mBAAmBgB,OAKxBA,GAAOjB,EAAKvB,WAIRuB,GAAKjE,QAAQE,WAMb+D,EAAKjE,QAAQQ,OAChB6D,EAAO5E,KAAKC,MAAM2E,EAAOJ,EAAKlC,eAAiBkC,EAAKlC,cAC1CkC,EAAKjE,QAAQS,WACvB4D,EAAO5E,KAAKC,MAAM2E,EAAOJ,EAAK9B,aAAe8B,EAAK9B,aAPnDkC,EAAOJ,EAAKtB,aAYRsB,EAAKjE,QAAQG,WAMb8D,EAAKjE,QAAQQ,OAChB8D,EAAM7E,KAAKC,MAAM4E,EAAML,EAAKjC,gBAAkBiC,EAAKjC,eACzCiC,EAAKjE,QAAQS,WACvB6D,EAAM7E,KAAKC,MAAM4E,EAAML,EAAK7B,cAAgB6B,EAAK7B,cAPlDkC,EAAML,EAAKrB,YAaZyB,EAAO5E,KAAKmG,IAAInG,KAAKG,IAAIqE,EAAKpB,gBAAiBwB,GAAO,GACtDC,EAAM7E,KAAKmG,IAAInG,KAAKG,IAAIqE,EAAKnB,eAAgBwB,GAAM,GAI/CD,IAASJ,EAAKtB,cAAgB2B,IAAQL,EAAKrB,cAC9C0C,GAAU,GAINrB,EAAK1C,cACL0C,EAAKc,UAAUV,EAAMC,EAAKY,EAAMI,IAatCS,SAAU,SAAS1B,EAAMC,EAAKgB,GAE7B,GAAIrB,GAAOxI,KAEPuK,EAAY/B,EAAKrC,cAAgBqC,EAAKlB,gBAAkBkB,EAAKtB,aAC7DsD,EAAWhC,EAAKrC,cAAgBqC,EAAKjB,eAAiBiB,EAAKrB,WAE/DqB,GAAKE,SAAS6B,GAAa3B,GAAQ,GAAI4B,GAAY3B,GAAO,GAAIgB,IAe/DY,YAAa,SAASC,EAAYC,EAAWC,EAAOC,GAEnD,GAAIrC,GAAOxI,KACP8K,EAASJ,EAAa,EAAI,IAAO,IAErC,OAAOlC,GAAKmB,OAAOnB,EAAKvB,YAAc6D,GAAQ,EAAOF,EAAQpC,EAAKpC,aAAcyE,EAAQrC,EAAKnC,cAQ9F0E,aAAc,SAASC,EAASL,GAG/B,GAAsB,MAAlBK,EAAQC,OACX,KAAM,IAAIjB,OAAM,uBAAyBgB,EAM1C,IAHIL,YAAqB5J,QACxB4J,EAAYA,EAAUO,WAEE,gBAAdP,GACV,KAAM,IAAIX,OAAM,4BAA8BW,EAG/C,IAAInC,GAAOxI,IAGXwI,GAAK2C,wBAAyB,EAG1B3C,EAAKtC,mBACR7E,KAAKC,OAAOT,QAAQ+B,KAAK4F,EAAKtC,kBAC9BsC,EAAKtC,kBAAmB,EACxBsC,EAAK2C,wBAAyB,GAI3B3C,EAAKrC,gBACR9E,KAAKC,OAAOT,QAAQ+B,KAAK4F,EAAKrC,eAC9BqC,EAAKrC,eAAgB,EACrBqC,EAAK2C,wBAAyB,EAI/B,IAAIC,GAAkBC,EAClBC,EAAmC,IAAnBN,EAAQC,MACxBK,IACHF,EAAmBJ,EAAQ,GAAGJ,MAC9BS,EAAkBL,EAAQ,GAAGH,QAE7BO,EAAmBpH,KAAKuH,IAAIP,EAAQ,GAAGJ,MAAQI,EAAQ,GAAGJ,OAAS,EACnES,EAAkBrH,KAAKuH,IAAIP,EAAQ,GAAGH,MAAQG,EAAQ,GAAGH,OAAS,GAInErC,EAAKgD,mBAAqBJ,EAC1B5C,EAAKiD,kBAAoBJ,EAGzB7C,EAAKkD,iBAAmBlD,EAAKvB,YAG7BuB,EAAKf,gBAAkB2D,EACvB5C,EAAKd,eAAiB2D,EAGtB7C,EAAKb,gBAAkBgD,EAGvBnC,EAAKmD,YAAc,EAGnBnD,EAAKoD,iBAAmBN,GAAiB9C,EAAKjE,QAAQE,WACtD+D,EAAKqD,iBAAmBP,GAAiB9C,EAAKjE,QAAQG,WAGtD8D,EAAK1C,cAAe,EAGpB0C,EAAKzC,2BAA4B,EAGjCyC,EAAKvC,cAAgBqF,EAGrB9C,EAAK3C,gBAAkByF,EAGvB9C,EAAKZ,gBAQNkE,YAAa,SAASd,EAASL,EAAWoB,GAGzC,GAAsB,MAAlBf,EAAQC,OACX,KAAM,IAAIjB,OAAM,uBAAyBgB,EAM1C,IAHIL,YAAqB5J,QACxB4J,EAAYA,EAAUO,WAEE,gBAAdP,GACV,KAAM,IAAIX,OAAM,4BAA8BW,EAG/C,IAAInC,GAAOxI,IAGX,IAAKwI,EAAK1C,aAAV,CAKA,GAAIsF,GAAkBC,CAGC,KAAnBL,EAAQC,QACXG,EAAmBpH,KAAKuH,IAAIP,EAAQ,GAAGJ,MAAQI,EAAQ,GAAGJ,OAAS,EACnES,EAAkBrH,KAAKuH,IAAIP,EAAQ,GAAGH,MAAQG,EAAQ,GAAGH,OAAS,IAElEO,EAAmBJ,EAAQ,GAAGJ,MAC9BS,EAAkBL,EAAQ,GAAGH,MAG9B,IAAImB,GAAYxD,EAAKZ,WAGrB,IAAIY,EAAKvC,aAAc,CAGtB,GAAIgG,GAAQb,EAAmB5C,EAAKf,gBAChCyE,EAAQb,EAAkB7C,EAAKd,eAG/ByE,EAAa3D,EAAKtB,aAClBkF,EAAY5D,EAAKrB,YACjByC,EAAQpB,EAAKvB,WAGjB,IAAa,MAAT8E,GAAiBvD,EAAKjE,QAAQU,QAAS,CAE1C,GAAIiF,GAAWN,CASf,IANAA,EAAQA,EAAQpB,EAAKmD,YAAcI,EAGnCnC,EAAQ5F,KAAKmG,IAAInG,KAAKG,IAAIyF,EAAOpB,EAAKjE,QAAQY,SAAUqD,EAAKjE,QAAQW,SAGjEgF,IAAaN,EAAO,CAGvB,GAAIyC,GAAsBjB,EAAmB5C,EAAKpC,aAC9CkG,EAAqBjB,EAAkB7C,EAAKnC,WAGhD8F,IAAeE,EAAsBF,GAAcvC,EAAQM,EAAYmC,EACvED,GAAcE,EAAqBF,GAAaxC,EAAQM,EAAYoC,EAGpE9D,EAAKC,mBAAmBmB,IAK1B,GAAIpB,EAAKoD,gBAAiB,CAEzBO,GAAcF,EAAQjM,KAAKuE,QAAQa,eACnC,IAAImH,GAAgB/D,EAAKpB,iBAErB+E,EAAaI,GAAiBJ,EAAa,KAG1C3D,EAAKjE,QAAQM,SAEhBsH,GAAeF,EAAQ,EAAKjM,KAAKuE,QAAQa,gBAIzC+G,EAFUA,EAAaI,EAEVA,EAIA,GAOhB,GAAI/D,EAAKqD,gBAAiB,CAEzBO,GAAaF,EAAQlM,KAAKuE,QAAQa,eAClC,IAAIoH,GAAehE,EAAKnB,gBAEpB+E,EAAYI,GAAgBJ,EAAY,KAGvC5D,EAAKjE,QAAQM,UAEhBuH,GAAcF,EAAQ,EAAIlM,KAAKuE,QAAQa,gBAGlCoD,EAAKoD,iBAA2C,MAAxBpD,EAAK5B,mBAE5B4B,EAAK3B,iBAAmBuF,IAAc5D,EAAK5B,iBAE/C4B,EAAK3B,iBAAkB,EACnB2B,EAAK1B,mBACR0B,EAAK1B,qBAGI0B,EAAK3B,iBAAmBuF,GAAa5D,EAAK5B,kBAEpD4B,EAAK3B,iBAAkB,EACnB2B,EAAKzB,qBACRyB,EAAKzB,yBAQRqF,EAFUA,EAAYI,EAEVA,EAIA,GAOXR,EAAUf,OAAS,IACtBe,EAAUS,OAAO,EAAG,IAIrBT,EAAUU,KAAKP,EAAYC,EAAWzB,GAGtCnC,EAAKc,UAAU6C,EAAYC,EAAWxC,OAGhC,CAEN,GAAI+C,GAA2BnE,EAAKjE,QAAQO,QAAU,EAAI,EACtD8H,EAAyB,EAEzBC,EAAY7I,KAAKuH,IAAIH,EAAmB5C,EAAKgD,oBAC7CsB,EAAY9I,KAAKuH,IAAIF,EAAkB7C,EAAKiD,kBAEhDjD,GAAKoD,gBAAkBpD,EAAKjE,QAAQE,YAAcoI,GAAaF,EAC/DnE,EAAKqD,gBAAkBrD,EAAKjE,QAAQG,YAAcoI,GAAaH,EAE/DX,EAAUU,KAAKlE,EAAKtB,aAAcsB,EAAKrB,YAAawD,GAEpDnC,EAAKvC,cAAgBuC,EAAKoD,iBAAmBpD,EAAKqD,mBAAqBgB,GAAaD,GAA0BE,GAAaF,GACvHpE,EAAKvC,eACRuC,EAAK2C,wBAAyB,GAMhC3C,EAAKf,gBAAkB2D,EACvB5C,EAAKd,eAAiB2D,EACtB7C,EAAKb,gBAAkBgD,EACvBnC,EAAKmD,YAAcI,IAQpBgB,WAAY,SAASpC,GAKpB,GAHIA,YAAqB5J,QACxB4J,EAAYA,EAAUO,WAEE,gBAAdP,GACV,KAAM,IAAIX,OAAM,4BAA8BW,EAG/C,IAAInC,GAAOxI,IAIX,IAAKwI,EAAK1C,aAAV,CASA,GAJA0C,EAAK1C,cAAe,EAIhB0C,EAAKvC,aAOR,GAJAuC,EAAKvC,cAAe,EAIhBuC,EAAK3C,iBAAmB2C,EAAKjE,QAAQI,WAAcgG,EAAYnC,EAAKb,iBAAoB,IAAK,CAQhG,IAAK,GALDqE,GAAYxD,EAAKZ,YACjBoF,EAAShB,EAAUf,OAAS,EAC5BgC,EAAWD,EAGNE,EAAIF,EAAQE,EAAI,GAAKlB,EAAUkB,GAAM1E,EAAKb,gBAAkB,IAAMuF,GAAK,EAC/ED,EAAWC,CAKZ,IAAID,IAAaD,EAAQ,CAGxB,GAAIG,GAAanB,EAAUgB,GAAUhB,EAAUiB,GAC3CG,EAAY5E,EAAKtB,aAAe8E,EAAUiB,EAAW,GACrDI,EAAW7E,EAAKrB,YAAc6E,EAAUiB,EAAW,EAGvDzE,GAAKP,wBAA0BmF,EAAYD,GAAc,IAAO,IAChE3E,EAAKN,wBAA0BmF,EAAWF,GAAc,IAAO,GAG/D,IAAIG,GAAiC9E,EAAKjE,QAAQQ,QAAUyD,EAAKjE,QAAQS,SAAW,EAAI,CAGpFhB,MAAKuH,IAAI/C,EAAKP,yBAA2BqF,GAAkCtJ,KAAKuH,IAAI/C,EAAKN,yBAA2BoF,EAGlH9E,EAAK3B,iBACT2B,EAAK+E,oBAAoB5C,GAG1BnC,EAAKjE,QAAQc,wBAGdmD,GAAKjE,QAAQc,wBAEHsF,GAAYnC,EAAKb,gBAAmB,KAC/Ca,EAAKjE,QAAQc,mBASVmD,GAAKtC,mBAELsC,EAAK3B,iBAAmB2B,EAAKxB,gBAIhCwB,EAAKc,UAAUd,EAAKtB,cAAesB,EAAK5B,gBAAiB4B,EAAKvB,aAAa,GAEvEuB,EAAKxB,gBACRwB,EAAKxB,oBAKFwB,EAAK2C,wBAA0B3C,EAAKvC,eACvCuC,EAAKjE,QAAQc,oBAEdmD,EAAKE,SAASF,EAAKtB,aAAcsB,EAAKrB,aAAa,EAAMqB,EAAKvB,aAG1DuB,EAAK3B,kBAER2B,EAAK3B,iBAAkB,EACnB2B,EAAKzB,qBACRyB,EAAKzB,yBAQTyB,EAAKZ,YAAYqD,OAAS,IAmB3B3B,UAAW,SAASV,EAAMC,EAAKY,EAAMI,GAEpC,GAAIrB,GAAOxI,KAGPwN,EAAehF,EAAKrC,aAMxB,IALIqH,IACHnM,KAAKC,OAAOT,QAAQ+B,KAAK4K,GACzBhF,EAAKrC,eAAgB,GAGlB0D,GAAWrB,EAAKjE,QAAQI,UAAW,CAGtC6D,EAAKlB,gBAAkBsB,EACvBJ,EAAKjB,eAAiBsB,EACtBL,EAAKhB,gBAAkBiC,CAEvB,IAAIgE,GAAUjF,EAAKtB,aACfwG,EAASlF,EAAKrB,YACdwG,EAAUnF,EAAKvB,YAEf2G,EAAWhF,EAAO6E,EAClBI,EAAUhF,EAAM6E,EAChBI,EAAWrE,EAAOkE,EAElB/J,EAAO,SAASN,EAAStC,EAAK8C,GAE7BA,IAEH0E,EAAKtB,aAAeuG,EAAWG,EAAWtK,EAC1CkF,EAAKrB,YAAcuG,EAAUG,EAAUvK,EACvCkF,EAAKvB,YAAc0G,EAAWG,EAAWxK,EAGrCkF,EAAKhE,YACRgE,EAAKhE,WAAWgE,EAAKtB,aAAcsB,EAAKrB,YAAaqB,EAAKvB,eAMzD8G,EAAS,SAAS1N,GACrB,MAAOmI,GAAKrC,gBAAkB9F,GAG3B2N,EAAY,SAASC,EAAyBC,EAAaC,GAC1DD,IAAgB1F,EAAKrC,gBACxBqC,EAAKrC,eAAgB,IAElBqC,EAAKzC,2BAA6BoI,IACrC3F,EAAKjE,QAAQc,oBAGVmD,EAAKjE,QAAQU,UAChBuD,EAAKC,qBACFD,EAAKyB,iBACPzB,EAAKyB,iBACLzB,EAAKyB,eAAiB,OAMzBzB,GAAKrC,cAAgB9E,KAAKC,OAAOT,QAAQkC,MAAMa,EAAMmK,EAAQC,EAAWxF,EAAKjE,QAAQK,kBAAmB4I,EAAehI,EAAeG,OAItI6C,GAAKlB,gBAAkBkB,EAAKtB,aAAe0B,EAC3CJ,EAAKjB,eAAiBiB,EAAKrB,YAAc0B,EACzCL,EAAKhB,gBAAkBgB,EAAKvB,YAAcwC,EAGtCjB,EAAKhE,YACRgE,EAAKhE,WAAWoE,EAAMC,EAAKY,GAIxBjB,EAAKjE,QAAQU,UAChBuD,EAAKC,qBACFD,EAAKyB,iBACPzB,EAAKyB,iBACLzB,EAAKyB,eAAiB,QAU1BxB,mBAAoB,SAAS2F,GAE5B,GAAI5F,GAAOxI,IAEM,OAAboO,IACHA,EAAY5F,EAAKvB,aAGlBuB,EAAKpB,gBAAkBpD,KAAKmG,IAAK3B,EAAKhC,eAAiB4H,EAAa5F,EAAKlC,cAAe,GACxFkC,EAAKnB,eAAiBrD,KAAKmG,IAAK3B,EAAK/B,gBAAkB2H,EAAa5F,EAAKjC,eAAgB,IAgB1FgH,oBAAqB,SAAS5C,GAE7B,GAAInC,GAAOxI,IAEX,IAAIwI,EAAKjE,QAAQQ,OAAQ,CAExB,GAAIoH,GAAanI,KAAKmG,IAAInG,KAAKG,IAAIqE,EAAKtB,aAAcsB,EAAKpB,iBAAkB,GACzEgF,EAAYpI,KAAKmG,IAAInG,KAAKG,IAAIqE,EAAKrB,YAAaqB,EAAKnB,gBAAiB,GACtEe,EAAcI,EAAKlC,cACnB+B,EAAeG,EAAKjC,cAIxBiC,GAAKX,4BAA8B7D,KAAKqK,MAAMlC,EAAa/D,GAAeA,EAC1EI,EAAKV,2BAA6B9D,KAAKqK,MAAMjC,EAAY/D,GAAgBA,EACzEG,EAAKT,4BAA8B/D,KAAKsK,KAAKnC,EAAa/D,GAAeA,EACzEI,EAAKR,2BAA6BhE,KAAKsK,KAAKlC,EAAY/D,GAAgBA,MAIxEG,GAAKX,4BAA8B,EACnCW,EAAKV,2BAA6B,EAClCU,EAAKT,4BAA8BS,EAAKpB,gBACxCoB,EAAKR,2BAA6BQ,EAAKnB,cAKxC,IAAIzD,GAAO,SAASN,EAAStC,EAAK8C,GACjC0E,EAAK+F,0BAA0BzK,IAI5B0K,EAAgChG,EAAKjE,QAAQS,SAAW,EAAI,KAI5D+I,EAAS,WACZ,GAAIU,GAAiBzK,KAAKuH,IAAI/C,EAAKP,0BAA4BuG,GAAiCxK,KAAKuH,IAAI/C,EAAKN,0BAA4BsG,CAI1I,OAHKC,KACJjG,EAAKzC,2BAA4B,GAE3B0I,GAGJT,EAAY,SAASC,EAAyBC,EAAaC,GAC9D3F,EAAKtC,kBAAmB,EACpBsC,EAAKzC,2BACRyC,EAAKjE,QAAQc,oBAIdmD,EAAKE,SAASF,EAAKtB,aAAcsB,EAAKrB,YAAaqB,EAAKjE,QAAQS,UAIjEwD,GAAKtC,iBAAmB7E,KAAKC,OAAOT,QAAQkC,MAAMa,EAAMmK,EAAQC,IAUjEO,0BAA2B,SAASzK,GAEnC,GAAI0E,GAAOxI,KAQPmM,EAAa3D,EAAKtB,aAAesB,EAAKP,wBACtCmE,EAAY5D,EAAKrB,YAAcqB,EAAKN,uBAOxC,KAAKM,EAAKjE,QAAQM,SAAU,CAE3B,GAAI6J,GAAkB1K,KAAKmG,IAAInG,KAAKG,IAAIqE,EAAKT,4BAA6BoE,GAAa3D,EAAKX,4BACxF6G,KAAoBvC,IACvBA,EAAauC,EACblG,EAAKP,wBAA0B,EAGhC,IAAI0G,GAAiB3K,KAAKmG,IAAInG,KAAKG,IAAIqE,EAAKR,2BAA4BoE,GAAY5D,EAAKV,2BACrF6G,KAAmBvC,IACtBA,EAAYuC,EACZnG,EAAKN,wBAA0B,GA2BjC,GAjBIpE,EAEH0E,EAAKc,UAAU6C,EAAYC,EAAW5D,EAAKvB,cAI3CuB,EAAKtB,aAAeiF,EACpB3D,EAAKrB,YAAciF,IAUf5D,EAAKjE,QAAQQ,OAAQ,CAKzB,GAAI6J,GAAiB,GAErBpG,GAAKP,yBAA2B2G,EAChCpG,EAAKN,yBAA2B0G,EASjC,GAAIpG,EAAKjE,QAAQM,SAAU,CAE1B,GAAIgK,GAAiB,EACjBC,EAAiB,EAGjBxJ,EAA0BkD,EAAKjE,QAAQe,wBACvCC,EAA0BiD,EAAKjE,QAAQgB,uBAGvC4G,GAAa3D,EAAKX,4BACrBgH,EAAiBrG,EAAKX,4BAA8BsE,EAC1CA,EAAa3D,EAAKT,8BAC5B8G,EAAiBrG,EAAKT,4BAA8BoE,GAGjDC,EAAY5D,EAAKV,2BACpBgH,EAAiBtG,EAAKV,2BAA6BsE,EACzCA,EAAY5D,EAAKR,6BAC3B8G,EAAiBtG,EAAKR,2BAA6BoE,GAI7B,IAAnByC,IACCA,EAAiBrG,EAAKP,yBAA2B,EACpDO,EAAKP,yBAA2B4G,EAAiBvJ,EAEjDkD,EAAKP,wBAA0B4G,EAAiBtJ,GAI3B,IAAnBuJ,IACCA,EAAiBtG,EAAKN,yBAA2B,EACpDM,EAAKN,yBAA2B4G,EAAiBxJ,EAEjDkD,EAAKN,wBAA0B4G,EAAiBvJ,KAQrD,KAAK,GAAI9C,KAAOmD,GACfjF,EAASoO,UAAUtM,GAAOmD,EAAQnD,MAIpC4B,OAAO1D,SAAWd,EAAOD,QAAUe","file":"scroller.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scroller\"] = factory();\n\telse\n\t\troot[\"scroller\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scroller\"] = factory();\n\telse\n\t\troot[\"scroller\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"/dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t__webpack_require__(1);\n\tScroller = __webpack_require__(3);\n\tmodule.exports = Scroller;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t/* WEBPACK VAR INJECTION */(function(global) {/*\n\t * Scroller\n\t * http://github.com/zynga/scroller\n\t *\n\t * Copyright 2011, Zynga Inc.\n\t * Licensed under the MIT License.\n\t * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n\t *\n\t * Based on the work of: Unify Project (unify-project.org)\n\t * http://unify-project.org\n\t * Copyright 2011, Deutsche Telekom AG\n\t * License: MIT + Apache (V2)\n\t */\n\t\n\t/**\n\t * Generic animation class with support for dropped frames both optional easing and duration.\n\t *\n\t * Optional duration is useful when the lifetime is defined by another condition than time\n\t * e.g. speed of an animating object, etc.\n\t *\n\t * Dropped frame logic allows to keep using the same updater logic independent from the actual\n\t * rendering. This eases a lot of cases where it might be pretty complex to break down a state\n\t * based on the pure time difference.\n\t */\n\tfunction Animate() {\n\t\tvar time = Date.now || function () {\n\t\t\treturn +new Date();\n\t\t};\n\t\tvar desiredFrames = 60;\n\t\tvar millisecondsPerSecond = 1000;\n\t\tvar running = {};\n\t\tvar counter = 1;\n\t\n\t\t// Create namespaces\n\t\n\t\n\t\tcore = { effect: {} };\n\t\n\t\t// var core = { effect : {} };\n\t\tcore.effect.Animate = {\n\t\n\t\t\t/**\n\t   * A requestAnimationFrame wrapper / polyfill.\n\t   *\n\t   * @param callback {Function} The callback to be invoked before the next repaint.\n\t   * @param root {HTMLElement} The root element for the repaint\n\t   */\n\t\t\trequestAnimationFrame: function () {\n\t\n\t\t\t\t// Check for request animation Frame support\n\t\t\t\tvar requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;\n\t\t\t\tvar isNative = !!requestFrame;\n\t\n\t\t\t\tif (requestFrame && !/requestAnimationFrame\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}/i.test(requestFrame.toString())) {\n\t\t\t\t\tisNative = false;\n\t\t\t\t}\n\t\n\t\t\t\tif (isNative) {\n\t\t\t\t\treturn function (callback, root) {\n\t\t\t\t\t\trequestFrame(callback, root);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\n\t\t\t\tvar TARGET_FPS = 60;\n\t\t\t\tvar requests = {};\n\t\t\t\tvar requestCount = 0;\n\t\t\t\tvar rafHandle = 1;\n\t\t\t\tvar intervalHandle = null;\n\t\t\t\tvar lastActive = +new Date();\n\t\n\t\t\t\treturn function (callback, root) {\n\t\t\t\t\tvar callbackHandle = rafHandle++;\n\t\n\t\t\t\t\t// Store callback\n\t\t\t\t\trequests[callbackHandle] = callback;\n\t\t\t\t\trequestCount++;\n\t\n\t\t\t\t\t// Create timeout at first request\n\t\t\t\t\tif (intervalHandle === null) {\n\t\n\t\t\t\t\t\tintervalHandle = setInterval(function () {\n\t\n\t\t\t\t\t\t\tvar time = +new Date();\n\t\t\t\t\t\t\tvar currentRequests = requests;\n\t\n\t\t\t\t\t\t\t// Reset data structure before executing callbacks\n\t\t\t\t\t\t\trequests = {};\n\t\t\t\t\t\t\trequestCount = 0;\n\t\n\t\t\t\t\t\t\tfor (var key in currentRequests) {\n\t\t\t\t\t\t\t\tif (currentRequests.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\t\tcurrentRequests[key](time);\n\t\t\t\t\t\t\t\t\tlastActive = time;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t\t// Disable the timeout when nothing happens for a certain\n\t\t\t\t\t\t\t// period of time\n\t\t\t\t\t\t\tif (time - lastActive > 2500) {\n\t\t\t\t\t\t\t\tclearInterval(intervalHandle);\n\t\t\t\t\t\t\t\tintervalHandle = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}, 1000 / TARGET_FPS);\n\t\t\t\t\t}\n\t\n\t\t\t\t\treturn callbackHandle;\n\t\t\t\t};\n\t\t\t}(),\n\t\n\t\t\t/**\n\t   * Stops the given animation.\n\t   *\n\t   * @param id {Integer} Unique animation ID\n\t   * @return {Boolean} Whether the animation was stopped (aka, was running before)\n\t   */\n\t\t\tstop: function (id) {\n\t\t\t\tvar cleared = running[id] != null;\n\t\t\t\tif (cleared) {\n\t\t\t\t\trunning[id] = null;\n\t\t\t\t}\n\t\n\t\t\t\treturn cleared;\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Whether the given animation is still running.\n\t   *\n\t   * @param id {Integer} Unique animation ID\n\t   * @return {Boolean} Whether the animation is still running\n\t   */\n\t\t\tisRunning: function (id) {\n\t\t\t\treturn running[id] != null;\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Start the animation.\n\t   *\n\t   * @param stepCallback {Function} Pointer to function which is executed on every step.\n\t   *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\n\t   * @param verifyCallback {Function} Executed before every animation step.\n\t   *   Signature of the method should be `function() { return continueWithAnimation; }`\n\t   * @param completedCallback {Function}\n\t   *   Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\n\t   * @param duration {Integer} Milliseconds to run the animation\n\t   * @param easingMethod {Function} Pointer to easing function\n\t   *   Signature of the method should be `function(percent) { return modifiedValue; }`\n\t   * @param root {Element ? document.body} Render root, when available. Used for internal\n\t   *   usage of requestAnimationFrame.\n\t   * @return {Integer} Identifier of animation. Can be used to stop it any time.\n\t   */\n\t\t\tstart: function (stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {\n\t\n\t\t\t\tvar start = time();\n\t\t\t\tvar lastFrame = start;\n\t\t\t\tvar percent = 0;\n\t\t\t\tvar dropCounter = 0;\n\t\t\t\tvar id = counter++;\n\t\n\t\t\t\tif (!root) {\n\t\t\t\t\troot = document.body;\n\t\t\t\t}\n\t\n\t\t\t\t// Compacting running db automatically every few new animations\n\t\t\t\tif (id % 20 === 0) {\n\t\t\t\t\tvar newRunning = {};\n\t\t\t\t\tfor (var usedId in running) {\n\t\t\t\t\t\tnewRunning[usedId] = true;\n\t\t\t\t\t}\n\t\t\t\t\trunning = newRunning;\n\t\t\t\t}\n\t\n\t\t\t\t// This is the internal step method which is called every few milliseconds\n\t\t\t\tvar step = function (virtual) {\n\t\n\t\t\t\t\t// Normalize virtual value\n\t\t\t\t\tvar render = virtual !== true;\n\t\n\t\t\t\t\t// Get current time\n\t\t\t\t\tvar now = time();\n\t\n\t\t\t\t\t// Verification is executed before next animation step\n\t\t\t\t\tif (!running[id] || verifyCallback && !verifyCallback(id)) {\n\t\n\t\t\t\t\t\trunning[id] = null;\n\t\t\t\t\t\tcompletedCallback && completedCallback(desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond), id, false);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// For the current rendering to apply let's update omitted steps in memory.\n\t\t\t\t\t// This is important to bring internal state variables up-to-date with progress in time.\n\t\t\t\t\tif (render) {\n\t\n\t\t\t\t\t\tvar droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;\n\t\t\t\t\t\tfor (var j = 0; j < Math.min(droppedFrames, 4); j++) {\n\t\t\t\t\t\t\tstep(true);\n\t\t\t\t\t\t\tdropCounter++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Compute percent value\n\t\t\t\t\tif (duration) {\n\t\t\t\t\t\tpercent = (now - start) / duration;\n\t\t\t\t\t\tif (percent > 1) {\n\t\t\t\t\t\t\tpercent = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Execute step callback, then...\n\t\t\t\t\tvar value = easingMethod ? easingMethod(percent) : percent;\n\t\t\t\t\tif ((stepCallback(value, now, render) === false || percent === 1) && render) {\n\t\t\t\t\t\trunning[id] = null;\n\t\t\t\t\t\tcompletedCallback && completedCallback(desiredFrames - dropCounter / ((now - start) / millisecondsPerSecond), id, percent === 1 || duration == null);\n\t\t\t\t\t} else if (render) {\n\t\t\t\t\t\tlastFrame = now;\n\t\t\t\t\t\tcore.effect.Animate.requestAnimationFrame(step, root);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\n\t\t\t\t// Mark as running\n\t\t\t\trunning[id] = true;\n\t\n\t\t\t\t// Init first step\n\t\t\t\tcore.effect.Animate.requestAnimationFrame(step, root);\n\t\n\t\t\t\t// Return unique animation ID\n\t\t\t\treturn id;\n\t\t\t}\n\t\t};\n\t\treturn global.core;\n\t}\n\twindow.core = Animate();\n\t/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))\n\n/***/ }),\n/* 2 */,\n/* 3 */\n/***/ (function(module, exports) {\n\n\t/*\n\t * Scroller\n\t * http://github.com/zynga/scroller\n\t *\n\t * Copyright 2011, Zynga Inc.\n\t * Licensed under the MIT License.\n\t * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n\t *\n\t * Based on the work of: Unify Project (unify-project.org)\n\t * http://unify-project.org\n\t * Copyright 2011, Deutsche Telekom AG\n\t * License: MIT + Apache (V2)\n\t */\n\t\n\tvar Scroller;\n\t(function () {\n\t\tvar NOOP = function () {};\n\t\n\t\t/**\n\t  * A pure logic 'component' for 'virtual' scrolling/zooming.\n\t  */\n\t\tScroller = function (callback, options) {\n\t\n\t\t\tthis.__callback = callback;\n\t\n\t\t\tthis.options = {\n\t\n\t\t\t\t/** Enable scrolling on x-axis */\n\t\t\t\tscrollingX: true,\n\t\n\t\t\t\t/** Enable scrolling on y-axis */\n\t\t\t\tscrollingY: true,\n\t\n\t\t\t\t/** Enable animations for deceleration, snap back, zooming and scrolling */\n\t\t\t\tanimating: true,\n\t\n\t\t\t\t/** duration for animations triggered by scrollTo/zoomTo */\n\t\t\t\tanimationDuration: 250,\n\t\n\t\t\t\t/** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n\t\t\t\tbouncing: true,\n\t\n\t\t\t\t/** Enable locking to the main axis if user moves only slightly on one of them at start */\n\t\t\t\tlocking: true,\n\t\n\t\t\t\t/** Enable pagination mode (switching between full page content panes) */\n\t\t\t\tpaging: false,\n\t\n\t\t\t\t/** Enable snapping of content to a configured pixel grid */\n\t\t\t\tsnapping: false,\n\t\n\t\t\t\t/** Enable zooming of content via API, fingers and mouse wheel */\n\t\t\t\tzooming: false,\n\t\n\t\t\t\t/** Minimum zoom level */\n\t\t\t\tminZoom: 0.5,\n\t\n\t\t\t\t/** Maximum zoom level */\n\t\t\t\tmaxZoom: 3,\n\t\n\t\t\t\t/** Multiply or decrease scrolling speed **/\n\t\t\t\tspeedMultiplier: 1,\n\t\n\t\t\t\t/** Callback that is fired on the later of touch end or deceleration end,\n\t   \tprovided that another scrolling action has not begun. Used to know\n\t   \twhen to fade out a scrollbar. */\n\t\t\t\tscrollingComplete: NOOP,\n\t\n\t\t\t\t/** This configures the amount of change applied to deceleration when reaching boundaries  **/\n\t\t\t\tpenetrationDeceleration: 0.03,\n\t\n\t\t\t\t/** This configures the amount of change applied to acceleration when reaching boundaries  **/\n\t\t\t\tpenetrationAcceleration: 0.08\n\t\n\t\t\t};\n\t\n\t\t\tfor (var key in options) {\n\t\t\t\tthis.options[key] = options[key];\n\t\t\t}\n\t\t};\n\t\n\t\t// Easing Equations (c) 2003 Robert Penner, all rights reserved.\n\t\t// Open source under the BSD License.\n\t\n\t\t/**\n\t  * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\n\t **/\n\t\tvar easeOutCubic = function (pos) {\n\t\t\treturn Math.pow(pos - 1, 3) + 1;\n\t\t};\n\t\n\t\t/**\n\t  * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\n\t **/\n\t\tvar easeInOutCubic = function (pos) {\n\t\t\tif ((pos /= 0.5) < 1) {\n\t\t\t\treturn 0.5 * Math.pow(pos, 3);\n\t\t\t}\n\t\n\t\t\treturn 0.5 * (Math.pow(pos - 2, 3) + 2);\n\t\t};\n\t\n\t\tvar members = {\n\t\n\t\t\t/*\n\t  ---------------------------------------------------------------------------\n\t  \tINTERNAL FIELDS :: STATUS\n\t  ---------------------------------------------------------------------------\n\t  */\n\t\n\t\t\t/** {Boolean} Whether only a single finger is used in touch handling */\n\t\t\t__isSingleTouch: false,\n\t\n\t\t\t/** {Boolean} Whether a touch event sequence is in progress */\n\t\t\t__isTracking: false,\n\t\n\t\t\t/** {Boolean} Whether a deceleration animation went to completion. */\n\t\t\t__didDecelerationComplete: false,\n\t\n\t\t\t/**\n\t   * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when\n\t   * a gesturestart event happens. This has higher priority than dragging.\n\t   */\n\t\t\t__isGesturing: false,\n\t\n\t\t\t/**\n\t   * {Boolean} Whether the user has moved by such a distance that we have enabled\n\t   * dragging mode. Hint: It's only enabled after some pixels of movement to\n\t   * not interrupt with clicks etc.\n\t   */\n\t\t\t__isDragging: false,\n\t\n\t\t\t/**\n\t   * {Boolean} Not touching and dragging anymore, and smoothly animating the\n\t   * touch sequence using deceleration.\n\t   */\n\t\t\t__isDecelerating: false,\n\t\n\t\t\t/**\n\t   * {Boolean} Smoothly animating the currently configured change\n\t   */\n\t\t\t__isAnimating: false,\n\t\n\t\t\t/*\n\t  ---------------------------------------------------------------------------\n\t  \tINTERNAL FIELDS :: DIMENSIONS\n\t  ---------------------------------------------------------------------------\n\t  */\n\t\n\t\t\t/** {Integer} Available outer left position (from document perspective) */\n\t\t\t__clientLeft: 0,\n\t\n\t\t\t/** {Integer} Available outer top position (from document perspective) */\n\t\t\t__clientTop: 0,\n\t\n\t\t\t/** {Integer} Available outer width */\n\t\t\t__clientWidth: 0,\n\t\n\t\t\t/** {Integer} Available outer height */\n\t\t\t__clientHeight: 0,\n\t\n\t\t\t/** {Integer} Outer width of content */\n\t\t\t__contentWidth: 0,\n\t\n\t\t\t/** {Integer} Outer height of content */\n\t\t\t__contentHeight: 0,\n\t\n\t\t\t/** {Integer} Snapping width for content */\n\t\t\t__snapWidth: 100,\n\t\n\t\t\t/** {Integer} Snapping height for content */\n\t\t\t__snapHeight: 100,\n\t\n\t\t\t/** {Integer} Height to assign to refresh area */\n\t\t\t__refreshHeight: null,\n\t\n\t\t\t/** {Boolean} Whether the refresh process is enabled when the event is released now */\n\t\t\t__refreshActive: false,\n\t\n\t\t\t/** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\n\t\t\t__refreshActivate: null,\n\t\n\t\t\t/** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\n\t\t\t__refreshDeactivate: null,\n\t\n\t\t\t/** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\n\t\t\t__refreshStart: null,\n\t\n\t\t\t/** {Number} Zoom level */\n\t\t\t__zoomLevel: 1,\n\t\n\t\t\t/** {Number} Scroll position on x-axis */\n\t\t\t__scrollLeft: 0,\n\t\n\t\t\t/** {Number} Scroll position on y-axis */\n\t\t\t__scrollTop: 0,\n\t\n\t\t\t/** {Integer} Maximum allowed scroll position on x-axis */\n\t\t\t__maxScrollLeft: 0,\n\t\n\t\t\t/** {Integer} Maximum allowed scroll position on y-axis */\n\t\t\t__maxScrollTop: 0,\n\t\n\t\t\t/* {Number} Scheduled left position (final position when animating) */\n\t\t\t__scheduledLeft: 0,\n\t\n\t\t\t/* {Number} Scheduled top position (final position when animating) */\n\t\t\t__scheduledTop: 0,\n\t\n\t\t\t/* {Number} Scheduled zoom level (final scale when animating) */\n\t\t\t__scheduledZoom: 0,\n\t\n\t\t\t/*\n\t  ---------------------------------------------------------------------------\n\t  \tINTERNAL FIELDS :: LAST POSITIONS\n\t  ---------------------------------------------------------------------------\n\t  */\n\t\n\t\t\t/** {Number} Left position of finger at start */\n\t\t\t__lastTouchLeft: null,\n\t\n\t\t\t/** {Number} Top position of finger at start */\n\t\t\t__lastTouchTop: null,\n\t\n\t\t\t/** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\n\t\t\t__lastTouchMove: null,\n\t\n\t\t\t/** {Array} List of positions, uses three indexes for each state: left, top, timestamp */\n\t\t\t__positions: null,\n\t\n\t\t\t/*\n\t  ---------------------------------------------------------------------------\n\t  \tINTERNAL FIELDS :: DECELERATION SUPPORT\n\t  ---------------------------------------------------------------------------\n\t  */\n\t\n\t\t\t/** {Integer} Minimum left scroll position during deceleration */\n\t\t\t__minDecelerationScrollLeft: null,\n\t\n\t\t\t/** {Integer} Minimum top scroll position during deceleration */\n\t\t\t__minDecelerationScrollTop: null,\n\t\n\t\t\t/** {Integer} Maximum left scroll position during deceleration */\n\t\t\t__maxDecelerationScrollLeft: null,\n\t\n\t\t\t/** {Integer} Maximum top scroll position during deceleration */\n\t\t\t__maxDecelerationScrollTop: null,\n\t\n\t\t\t/** {Number} Current factor to modify horizontal scroll position with on every step */\n\t\t\t__decelerationVelocityX: null,\n\t\n\t\t\t/** {Number} Current factor to modify vertical scroll position with on every step */\n\t\t\t__decelerationVelocityY: null,\n\t\n\t\t\t/*\n\t  ---------------------------------------------------------------------------\n\t  \tPUBLIC API\n\t  ---------------------------------------------------------------------------\n\t  */\n\t\n\t\t\t/**\n\t   * Configures the dimensions of the client (outer) and content (inner) elements.\n\t   * Requires the available space for the outer element and the outer size of the inner element.\n\t   * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\n\t   *\n\t   * @param clientWidth {Integer ? null} Inner width of outer element\n\t   * @param clientHeight {Integer ? null} Inner height of outer element\n\t   * @param contentWidth {Integer ? null} Outer width of inner element\n\t   * @param contentHeight {Integer ? null} Outer height of inner element\n\t   */\n\t\t\tsetDimensions: function (clientWidth, clientHeight, contentWidth, contentHeight) {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\t// Only update values which are defined\n\t\t\t\tif (clientWidth === +clientWidth) {\n\t\t\t\t\tself.__clientWidth = clientWidth;\n\t\t\t\t}\n\t\n\t\t\t\tif (clientHeight === +clientHeight) {\n\t\t\t\t\tself.__clientHeight = clientHeight;\n\t\t\t\t}\n\t\n\t\t\t\tif (contentWidth === +contentWidth) {\n\t\t\t\t\tself.__contentWidth = contentWidth;\n\t\t\t\t}\n\t\n\t\t\t\tif (contentHeight === +contentHeight) {\n\t\t\t\t\tself.__contentHeight = contentHeight;\n\t\t\t\t}\n\t\n\t\t\t\t// Refresh maximums\n\t\t\t\tself.__computeScrollMax();\n\t\n\t\t\t\t// Refresh scroll position\n\t\t\t\tself.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Sets the client coordinates in relation to the document.\n\t   *\n\t   * @param left {Integer ? 0} Left position of outer element\n\t   * @param top {Integer ? 0} Top position of outer element\n\t   */\n\t\t\tsetPosition: function (left, top) {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\tself.__clientLeft = left || 0;\n\t\t\t\tself.__clientTop = top || 0;\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Configures the snapping (when snapping is active)\n\t   *\n\t   * @param width {Integer} Snapping width\n\t   * @param height {Integer} Snapping height\n\t   */\n\t\t\tsetSnapSize: function (width, height) {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\tself.__snapWidth = width;\n\t\t\t\tself.__snapHeight = height;\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\n\t   * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\n\t   * the official Twitter client.\n\t   *\n\t   * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\n\t   * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\n\t   * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\n\t   * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\n\t   */\n\t\t\tactivatePullToRefresh: function (height, activateCallback, deactivateCallback, startCallback) {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\tself.__refreshHeight = height;\n\t\t\t\tself.__refreshActivate = activateCallback;\n\t\t\t\tself.__refreshDeactivate = deactivateCallback;\n\t\t\t\tself.__refreshStart = startCallback;\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Starts pull-to-refresh manually.\n\t   */\n\t\t\ttriggerPullToRefresh: function () {\n\t\t\t\t// Use publish instead of scrollTo to allow scrolling to out of boundary position\n\t\t\t\t// We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n\t\t\t\tthis.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, true);\n\t\n\t\t\t\tif (this.__refreshStart) {\n\t\t\t\t\tthis.__refreshStart();\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Signalizes that pull-to-refresh is finished.\n\t   */\n\t\t\tfinishPullToRefresh: function () {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\tself.__refreshActive = false;\n\t\t\t\tif (self.__refreshDeactivate) {\n\t\t\t\t\tself.__refreshDeactivate();\n\t\t\t\t}\n\t\n\t\t\t\tself.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Returns the scroll position and zooming values\n\t   *\n\t   * @return {Map} `left` and `top` scroll position and `zoom` level\n\t   */\n\t\t\tgetValues: function () {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\treturn {\n\t\t\t\t\tleft: self.__scrollLeft,\n\t\t\t\t\ttop: self.__scrollTop,\n\t\t\t\t\tzoom: self.__zoomLevel\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Returns the maximum scroll values\n\t   *\n\t   * @return {Map} `left` and `top` maximum scroll values\n\t   */\n\t\t\tgetScrollMax: function () {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\treturn {\n\t\t\t\t\tleft: self.__maxScrollLeft,\n\t\t\t\t\ttop: self.__maxScrollTop\n\t\t\t\t};\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Zooms to the given level. Supports optional animation. Zooms\n\t   * the center when no coordinates are given.\n\t   *\n\t   * @param level {Number} Level to zoom to\n\t   * @param animate {Boolean ? false} Whether to use animation\n\t   * @param originLeft {Number ? null} Zoom in at given left coordinate\n\t   * @param originTop {Number ? null} Zoom in at given top coordinate\n\t   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n\t   */\n\t\t\tzoomTo: function (level, animate, originLeft, originTop, callback) {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\tif (!self.options.zooming) {\n\t\t\t\t\tthrow new Error(\"Zooming is not enabled!\");\n\t\t\t\t}\n\t\n\t\t\t\t// Add callback if exists\n\t\t\t\tif (callback) {\n\t\t\t\t\tself.__zoomComplete = callback;\n\t\t\t\t}\n\t\n\t\t\t\t// Stop deceleration\n\t\t\t\tif (self.__isDecelerating) {\n\t\t\t\t\tcore.effect.Animate.stop(self.__isDecelerating);\n\t\t\t\t\tself.__isDecelerating = false;\n\t\t\t\t}\n\t\n\t\t\t\tvar oldLevel = self.__zoomLevel;\n\t\n\t\t\t\t// Normalize input origin to center of viewport if not defined\n\t\t\t\tif (originLeft == null) {\n\t\t\t\t\toriginLeft = self.__clientWidth / 2;\n\t\t\t\t}\n\t\n\t\t\t\tif (originTop == null) {\n\t\t\t\t\toriginTop = self.__clientHeight / 2;\n\t\t\t\t}\n\t\n\t\t\t\t// Limit level according to configuration\n\t\t\t\tlevel = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);\n\t\n\t\t\t\t// Recompute maximum values while temporary tweaking maximum scroll ranges\n\t\t\t\tself.__computeScrollMax(level);\n\t\n\t\t\t\t// Recompute left and top coordinates based on new zoom level\n\t\t\t\tvar left = (originLeft + self.__scrollLeft) * level / oldLevel - originLeft;\n\t\t\t\tvar top = (originTop + self.__scrollTop) * level / oldLevel - originTop;\n\t\n\t\t\t\t// Limit x-axis\n\t\t\t\tif (left > self.__maxScrollLeft) {\n\t\t\t\t\tleft = self.__maxScrollLeft;\n\t\t\t\t} else if (left < 0) {\n\t\t\t\t\tleft = 0;\n\t\t\t\t}\n\t\n\t\t\t\t// Limit y-axis\n\t\t\t\tif (top > self.__maxScrollTop) {\n\t\t\t\t\ttop = self.__maxScrollTop;\n\t\t\t\t} else if (top < 0) {\n\t\t\t\t\ttop = 0;\n\t\t\t\t}\n\t\n\t\t\t\t// Push values out\n\t\t\t\tself.__publish(left, top, level, animate);\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Zooms the content by the given factor.\n\t   *\n\t   * @param factor {Number} Zoom by given factor\n\t   * @param animate {Boolean ? false} Whether to use animation\n\t   * @param originLeft {Number ? 0} Zoom in at given left coordinate\n\t   * @param originTop {Number ? 0} Zoom in at given top coordinate\n\t   * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n\t   */\n\t\t\tzoomBy: function (factor, animate, originLeft, originTop, callback) {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\tself.zoomTo(self.__zoomLevel * factor, animate, originLeft, originTop, callback);\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Scrolls to the given position. Respect limitations and snapping automatically.\n\t   *\n\t   * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\n\t   * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\n\t   * @param animate {Boolean?false} Whether the scrolling should happen using an animation\n\t   * @param zoom {Number?null} Zoom level to go to\n\t   */\n\t\t\tscrollTo: function (left, top, animate, zoom) {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\t// Stop deceleration\n\t\t\t\tif (self.__isDecelerating) {\n\t\t\t\t\tcore.effect.Animate.stop(self.__isDecelerating);\n\t\t\t\t\tself.__isDecelerating = false;\n\t\t\t\t}\n\t\n\t\t\t\t// Correct coordinates based on new zoom level\n\t\t\t\tif (zoom != null && zoom !== self.__zoomLevel) {\n\t\n\t\t\t\t\tif (!self.options.zooming) {\n\t\t\t\t\t\tthrow new Error(\"Zooming is not enabled!\");\n\t\t\t\t\t}\n\t\n\t\t\t\t\tleft *= zoom;\n\t\t\t\t\ttop *= zoom;\n\t\n\t\t\t\t\t// Recompute maximum values while temporary tweaking maximum scroll ranges\n\t\t\t\t\tself.__computeScrollMax(zoom);\n\t\t\t\t} else {\n\t\n\t\t\t\t\t// Keep zoom when not defined\n\t\t\t\t\tzoom = self.__zoomLevel;\n\t\t\t\t}\n\t\n\t\t\t\tif (!self.options.scrollingX) {\n\t\n\t\t\t\t\tleft = self.__scrollLeft;\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif (self.options.paging) {\n\t\t\t\t\t\tleft = Math.round(left / self.__clientWidth) * self.__clientWidth;\n\t\t\t\t\t} else if (self.options.snapping) {\n\t\t\t\t\t\tleft = Math.round(left / self.__snapWidth) * self.__snapWidth;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\tif (!self.options.scrollingY) {\n\t\n\t\t\t\t\ttop = self.__scrollTop;\n\t\t\t\t} else {\n\t\n\t\t\t\t\tif (self.options.paging) {\n\t\t\t\t\t\ttop = Math.round(top / self.__clientHeight) * self.__clientHeight;\n\t\t\t\t\t} else if (self.options.snapping) {\n\t\t\t\t\t\ttop = Math.round(top / self.__snapHeight) * self.__snapHeight;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Limit for allowed ranges\n\t\t\t\tleft = Math.max(Math.min(self.__maxScrollLeft, left), 0);\n\t\t\t\ttop = Math.max(Math.min(self.__maxScrollTop, top), 0);\n\t\n\t\t\t\t// Don't animate when no change detected, still call publish to make sure\n\t\t\t\t// that rendered position is really in-sync with internal data\n\t\t\t\tif (left === self.__scrollLeft && top === self.__scrollTop) {\n\t\t\t\t\tanimate = false;\n\t\t\t\t}\n\t\n\t\t\t\t// Publish new values\n\t\t\t\tif (!self.__isTracking) {\n\t\t\t\t\tself.__publish(left, top, zoom, animate);\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Scroll by the given offset\n\t   *\n\t   * @param left {Number ? 0} Scroll x-axis by given offset\n\t   * @param top {Number ? 0} Scroll x-axis by given offset\n\t   * @param animate {Boolean ? false} Whether to animate the given change\n\t   */\n\t\t\tscrollBy: function (left, top, animate) {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\tvar startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;\n\t\t\t\tvar startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;\n\t\n\t\t\t\tself.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\n\t\t\t},\n\t\n\t\t\t/*\n\t  ---------------------------------------------------------------------------\n\t  \tEVENT CALLBACKS\n\t  ---------------------------------------------------------------------------\n\t  */\n\t\n\t\t\t/**\n\t   * Mouse wheel handler for zooming support\n\t   */\n\t\t\tdoMouseZoom: function (wheelDelta, timeStamp, pageX, pageY) {\n\t\n\t\t\t\tvar self = this;\n\t\t\t\tvar change = wheelDelta > 0 ? 0.97 : 1.03;\n\t\n\t\t\t\treturn self.zoomTo(self.__zoomLevel * change, false, pageX - self.__clientLeft, pageY - self.__clientTop);\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Touch start handler for scrolling support\n\t   */\n\t\t\tdoTouchStart: function (touches, timeStamp) {\n\t\n\t\t\t\t// Array-like check is enough here\n\t\t\t\tif (touches.length == null) {\n\t\t\t\t\tthrow new Error(\"Invalid touch list: \" + touches);\n\t\t\t\t}\n\t\n\t\t\t\tif (timeStamp instanceof Date) {\n\t\t\t\t\ttimeStamp = timeStamp.valueOf();\n\t\t\t\t}\n\t\t\t\tif (typeof timeStamp !== \"number\") {\n\t\t\t\t\tthrow new Error(\"Invalid timestamp value: \" + timeStamp);\n\t\t\t\t}\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\t// Reset interruptedAnimation flag\n\t\t\t\tself.__interruptedAnimation = true;\n\t\n\t\t\t\t// Stop deceleration\n\t\t\t\tif (self.__isDecelerating) {\n\t\t\t\t\tcore.effect.Animate.stop(self.__isDecelerating);\n\t\t\t\t\tself.__isDecelerating = false;\n\t\t\t\t\tself.__interruptedAnimation = true;\n\t\t\t\t}\n\t\n\t\t\t\t// Stop animation\n\t\t\t\tif (self.__isAnimating) {\n\t\t\t\t\tcore.effect.Animate.stop(self.__isAnimating);\n\t\t\t\t\tself.__isAnimating = false;\n\t\t\t\t\tself.__interruptedAnimation = true;\n\t\t\t\t}\n\t\n\t\t\t\t// Use center point when dealing with two fingers\n\t\t\t\tvar currentTouchLeft, currentTouchTop;\n\t\t\t\tvar isSingleTouch = touches.length === 1;\n\t\t\t\tif (isSingleTouch) {\n\t\t\t\t\tcurrentTouchLeft = touches[0].pageX;\n\t\t\t\t\tcurrentTouchTop = touches[0].pageY;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n\t\t\t\t\tcurrentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n\t\t\t\t}\n\t\n\t\t\t\t// Store initial positions\n\t\t\t\tself.__initialTouchLeft = currentTouchLeft;\n\t\t\t\tself.__initialTouchTop = currentTouchTop;\n\t\n\t\t\t\t// Store current zoom level\n\t\t\t\tself.__zoomLevelStart = self.__zoomLevel;\n\t\n\t\t\t\t// Store initial touch positions\n\t\t\t\tself.__lastTouchLeft = currentTouchLeft;\n\t\t\t\tself.__lastTouchTop = currentTouchTop;\n\t\n\t\t\t\t// Store initial move time stamp\n\t\t\t\tself.__lastTouchMove = timeStamp;\n\t\n\t\t\t\t// Reset initial scale\n\t\t\t\tself.__lastScale = 1;\n\t\n\t\t\t\t// Reset locking flags\n\t\t\t\tself.__enableScrollX = !isSingleTouch && self.options.scrollingX;\n\t\t\t\tself.__enableScrollY = !isSingleTouch && self.options.scrollingY;\n\t\n\t\t\t\t// Reset tracking flag\n\t\t\t\tself.__isTracking = true;\n\t\n\t\t\t\t// Reset deceleration complete flag\n\t\t\t\tself.__didDecelerationComplete = false;\n\t\n\t\t\t\t// Dragging starts directly with two fingers, otherwise lazy with an offset\n\t\t\t\tself.__isDragging = !isSingleTouch;\n\t\n\t\t\t\t// Some features are disabled in multi touch scenarios\n\t\t\t\tself.__isSingleTouch = isSingleTouch;\n\t\n\t\t\t\t// Clearing data structure\n\t\t\t\tself.__positions = [];\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Touch move handler for scrolling support\n\t   */\n\t\t\tdoTouchMove: function (touches, timeStamp, scale) {\n\t\n\t\t\t\t// Array-like check is enough here\n\t\t\t\tif (touches.length == null) {\n\t\t\t\t\tthrow new Error(\"Invalid touch list: \" + touches);\n\t\t\t\t}\n\t\n\t\t\t\tif (timeStamp instanceof Date) {\n\t\t\t\t\ttimeStamp = timeStamp.valueOf();\n\t\t\t\t}\n\t\t\t\tif (typeof timeStamp !== \"number\") {\n\t\t\t\t\tthrow new Error(\"Invalid timestamp value: \" + timeStamp);\n\t\t\t\t}\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\t// Ignore event when tracking is not enabled (event might be outside of element)\n\t\t\t\tif (!self.__isTracking) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\tvar currentTouchLeft, currentTouchTop;\n\t\n\t\t\t\t// Compute move based around of center of fingers\n\t\t\t\tif (touches.length === 2) {\n\t\t\t\t\tcurrentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n\t\t\t\t\tcurrentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentTouchLeft = touches[0].pageX;\n\t\t\t\t\tcurrentTouchTop = touches[0].pageY;\n\t\t\t\t}\n\t\n\t\t\t\tvar positions = self.__positions;\n\t\n\t\t\t\t// Are we already is dragging mode?\n\t\t\t\tif (self.__isDragging) {\n\t\n\t\t\t\t\t// Compute move distance\n\t\t\t\t\tvar moveX = currentTouchLeft - self.__lastTouchLeft;\n\t\t\t\t\tvar moveY = currentTouchTop - self.__lastTouchTop;\n\t\n\t\t\t\t\t// Read previous scroll position and zooming\n\t\t\t\t\tvar scrollLeft = self.__scrollLeft;\n\t\t\t\t\tvar scrollTop = self.__scrollTop;\n\t\t\t\t\tvar level = self.__zoomLevel;\n\t\n\t\t\t\t\t// Work with scaling\n\t\t\t\t\tif (scale != null && self.options.zooming) {\n\t\n\t\t\t\t\t\tvar oldLevel = level;\n\t\n\t\t\t\t\t\t// Recompute level based on previous scale and new scale\n\t\t\t\t\t\tlevel = level / self.__lastScale * scale;\n\t\n\t\t\t\t\t\t// Limit level according to configuration\n\t\t\t\t\t\tlevel = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);\n\t\n\t\t\t\t\t\t// Only do further compution when change happened\n\t\t\t\t\t\tif (oldLevel !== level) {\n\t\n\t\t\t\t\t\t\t// Compute relative event position to container\n\t\t\t\t\t\t\tvar currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\n\t\t\t\t\t\t\tvar currentTouchTopRel = currentTouchTop - self.__clientTop;\n\t\n\t\t\t\t\t\t\t// Recompute left and top coordinates based on new zoom level\n\t\t\t\t\t\t\tscrollLeft = (currentTouchLeftRel + scrollLeft) * level / oldLevel - currentTouchLeftRel;\n\t\t\t\t\t\t\tscrollTop = (currentTouchTopRel + scrollTop) * level / oldLevel - currentTouchTopRel;\n\t\n\t\t\t\t\t\t\t// Recompute max scroll values\n\t\t\t\t\t\t\tself.__computeScrollMax(level);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (self.__enableScrollX) {\n\t\n\t\t\t\t\t\tscrollLeft -= moveX * this.options.speedMultiplier;\n\t\t\t\t\t\tvar maxScrollLeft = self.__maxScrollLeft;\n\t\n\t\t\t\t\t\tif (scrollLeft > maxScrollLeft || scrollLeft < 0) {\n\t\n\t\t\t\t\t\t\t// Slow down on the edges\n\t\t\t\t\t\t\tif (self.options.bouncing) {\n\t\n\t\t\t\t\t\t\t\tscrollLeft += moveX / 2 * this.options.speedMultiplier;\n\t\t\t\t\t\t\t} else if (scrollLeft > maxScrollLeft) {\n\t\n\t\t\t\t\t\t\t\tscrollLeft = maxScrollLeft;\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tscrollLeft = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Compute new vertical scroll position\n\t\t\t\t\tif (self.__enableScrollY) {\n\t\n\t\t\t\t\t\tscrollTop -= moveY * this.options.speedMultiplier;\n\t\t\t\t\t\tvar maxScrollTop = self.__maxScrollTop;\n\t\n\t\t\t\t\t\tif (scrollTop > maxScrollTop || scrollTop < 0) {\n\t\n\t\t\t\t\t\t\t// Slow down on the edges\n\t\t\t\t\t\t\tif (self.options.bouncing) {\n\t\n\t\t\t\t\t\t\t\tscrollTop += moveY / 2 * this.options.speedMultiplier;\n\t\n\t\t\t\t\t\t\t\t// Support pull-to-refresh (only when only y is scrollable)\n\t\t\t\t\t\t\t\tif (!self.__enableScrollX && self.__refreshHeight != null) {\n\t\n\t\t\t\t\t\t\t\t\tif (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {\n\t\n\t\t\t\t\t\t\t\t\t\tself.__refreshActive = true;\n\t\t\t\t\t\t\t\t\t\tif (self.__refreshActivate) {\n\t\t\t\t\t\t\t\t\t\t\tself.__refreshActivate();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} else if (self.__refreshActive && scrollTop > -self.__refreshHeight) {\n\t\n\t\t\t\t\t\t\t\t\t\tself.__refreshActive = false;\n\t\t\t\t\t\t\t\t\t\tif (self.__refreshDeactivate) {\n\t\t\t\t\t\t\t\t\t\t\tself.__refreshDeactivate();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if (scrollTop > maxScrollTop) {\n\t\n\t\t\t\t\t\t\t\tscrollTop = maxScrollTop;\n\t\t\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\t\t\tscrollTop = 0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Keep list from growing infinitely (holding min 10, max 20 measure points)\n\t\t\t\t\tif (positions.length > 60) {\n\t\t\t\t\t\tpositions.splice(0, 30);\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Track scroll movement for decleration\n\t\t\t\t\tpositions.push(scrollLeft, scrollTop, timeStamp);\n\t\n\t\t\t\t\t// Sync scroll position\n\t\t\t\t\tself.__publish(scrollLeft, scrollTop, level);\n\t\n\t\t\t\t\t// Otherwise figure out whether we are switching into dragging mode now.\n\t\t\t\t} else {\n\t\n\t\t\t\t\tvar minimumTrackingForScroll = self.options.locking ? 3 : 0;\n\t\t\t\t\tvar minimumTrackingForDrag = 5;\n\t\n\t\t\t\t\tvar distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\n\t\t\t\t\tvar distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\n\t\n\t\t\t\t\tself.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll;\n\t\t\t\t\tself.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll;\n\t\n\t\t\t\t\tpositions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\n\t\n\t\t\t\t\tself.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);\n\t\t\t\t\tif (self.__isDragging) {\n\t\t\t\t\t\tself.__interruptedAnimation = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Update last touch positions and time stamp for next event\n\t\t\t\tself.__lastTouchLeft = currentTouchLeft;\n\t\t\t\tself.__lastTouchTop = currentTouchTop;\n\t\t\t\tself.__lastTouchMove = timeStamp;\n\t\t\t\tself.__lastScale = scale;\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Touch end handler for scrolling support\n\t   */\n\t\t\tdoTouchEnd: function (timeStamp) {\n\t\n\t\t\t\tif (timeStamp instanceof Date) {\n\t\t\t\t\ttimeStamp = timeStamp.valueOf();\n\t\t\t\t}\n\t\t\t\tif (typeof timeStamp !== \"number\") {\n\t\t\t\t\tthrow new Error(\"Invalid timestamp value: \" + timeStamp);\n\t\t\t\t}\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\t// Ignore event when tracking is not enabled (no touchstart event on element)\n\t\t\t\t// This is required as this listener ('touchmove') sits on the document and not on the element itself.\n\t\t\t\tif (!self.__isTracking) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\n\t\t\t\t// Not touching anymore (when two finger hit the screen there are two touch end events)\n\t\t\t\tself.__isTracking = false;\n\t\n\t\t\t\t// Be sure to reset the dragging flag now. Here we also detect whether\n\t\t\t\t// the finger has moved fast enough to switch into a deceleration animation.\n\t\t\t\tif (self.__isDragging) {\n\t\n\t\t\t\t\t// Reset dragging flag\n\t\t\t\t\tself.__isDragging = false;\n\t\n\t\t\t\t\t// Start deceleration\n\t\t\t\t\t// Verify that the last move detected was in some relevant time frame\n\t\t\t\t\tif (self.__isSingleTouch && self.options.animating && timeStamp - self.__lastTouchMove <= 100) {\n\t\n\t\t\t\t\t\t// Then figure out what the scroll position was about 100ms ago\n\t\t\t\t\t\tvar positions = self.__positions;\n\t\t\t\t\t\tvar endPos = positions.length - 1;\n\t\t\t\t\t\tvar startPos = endPos;\n\t\n\t\t\t\t\t\t// Move pointer to position measured 100ms ago\n\t\t\t\t\t\tfor (var i = endPos; i > 0 && positions[i] > self.__lastTouchMove - 100; i -= 3) {\n\t\t\t\t\t\t\tstartPos = i;\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\t// If start and stop position is identical in a 100ms timeframe,\n\t\t\t\t\t\t// we cannot compute any useful deceleration.\n\t\t\t\t\t\tif (startPos !== endPos) {\n\t\n\t\t\t\t\t\t\t// Compute relative movement between these two points\n\t\t\t\t\t\t\tvar timeOffset = positions[endPos] - positions[startPos];\n\t\t\t\t\t\t\tvar movedLeft = self.__scrollLeft - positions[startPos - 2];\n\t\t\t\t\t\t\tvar movedTop = self.__scrollTop - positions[startPos - 1];\n\t\n\t\t\t\t\t\t\t// Based on 50ms compute the movement to apply for each render step\n\t\t\t\t\t\t\tself.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);\n\t\t\t\t\t\t\tself.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);\n\t\n\t\t\t\t\t\t\t// How much velocity is required to start the deceleration\n\t\t\t\t\t\t\tvar minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? 4 : 1;\n\t\n\t\t\t\t\t\t\t// Verify that we have enough velocity to start deceleration\n\t\t\t\t\t\t\tif (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) {\n\t\n\t\t\t\t\t\t\t\t// Deactivate pull-to-refresh when decelerating\n\t\t\t\t\t\t\t\tif (!self.__refreshActive) {\n\t\t\t\t\t\t\t\t\tself.__startDeceleration(timeStamp);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tself.options.scrollingComplete();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.options.scrollingComplete();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if (timeStamp - self.__lastTouchMove > 100) {\n\t\t\t\t\t\tself.options.scrollingComplete();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// If this was a slower move it is per default non decelerated, but this\n\t\t\t\t// still means that we want snap back to the bounds which is done here.\n\t\t\t\t// This is placed outside the condition above to improve edge case stability\n\t\t\t\t// e.g. touchend fired without enabled dragging. This should normally do not\n\t\t\t\t// have modified the scroll positions or even showed the scrollbars though.\n\t\t\t\tif (!self.__isDecelerating) {\n\t\n\t\t\t\t\tif (self.__refreshActive && self.__refreshStart) {\n\t\n\t\t\t\t\t\t// Use publish instead of scrollTo to allow scrolling to out of boundary position\n\t\t\t\t\t\t// We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n\t\t\t\t\t\tself.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, true);\n\t\n\t\t\t\t\t\tif (self.__refreshStart) {\n\t\t\t\t\t\t\tself.__refreshStart();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\n\t\t\t\t\t\tif (self.__interruptedAnimation || self.__isDragging) {\n\t\t\t\t\t\t\tself.options.scrollingComplete();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tself.scrollTo(self.__scrollLeft, self.__scrollTop, true, self.__zoomLevel);\n\t\n\t\t\t\t\t\t// Directly signalize deactivation (nothing todo on refresh?)\n\t\t\t\t\t\tif (self.__refreshActive) {\n\t\n\t\t\t\t\t\t\tself.__refreshActive = false;\n\t\t\t\t\t\t\tif (self.__refreshDeactivate) {\n\t\t\t\t\t\t\t\tself.__refreshDeactivate();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t// Fully cleanup list\n\t\t\t\tself.__positions.length = 0;\n\t\t\t},\n\t\n\t\t\t/*\n\t  ---------------------------------------------------------------------------\n\t  \tPRIVATE API\n\t  ---------------------------------------------------------------------------\n\t  */\n\t\n\t\t\t/**\n\t   * Applies the scroll position to the content element\n\t   *\n\t   * @param left {Number} Left scroll position\n\t   * @param top {Number} Top scroll position\n\t   * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates\n\t   */\n\t\t\t__publish: function (left, top, zoom, animate) {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\t// Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\n\t\t\t\tvar wasAnimating = self.__isAnimating;\n\t\t\t\tif (wasAnimating) {\n\t\t\t\t\tcore.effect.Animate.stop(wasAnimating);\n\t\t\t\t\tself.__isAnimating = false;\n\t\t\t\t}\n\t\n\t\t\t\tif (animate && self.options.animating) {\n\t\n\t\t\t\t\t// Keep scheduled positions for scrollBy/zoomBy functionality\n\t\t\t\t\tself.__scheduledLeft = left;\n\t\t\t\t\tself.__scheduledTop = top;\n\t\t\t\t\tself.__scheduledZoom = zoom;\n\t\n\t\t\t\t\tvar oldLeft = self.__scrollLeft;\n\t\t\t\t\tvar oldTop = self.__scrollTop;\n\t\t\t\t\tvar oldZoom = self.__zoomLevel;\n\t\n\t\t\t\t\tvar diffLeft = left - oldLeft;\n\t\t\t\t\tvar diffTop = top - oldTop;\n\t\t\t\t\tvar diffZoom = zoom - oldZoom;\n\t\n\t\t\t\t\tvar step = function (percent, now, render) {\n\t\n\t\t\t\t\t\tif (render) {\n\t\n\t\t\t\t\t\t\tself.__scrollLeft = oldLeft + diffLeft * percent;\n\t\t\t\t\t\t\tself.__scrollTop = oldTop + diffTop * percent;\n\t\t\t\t\t\t\tself.__zoomLevel = oldZoom + diffZoom * percent;\n\t\n\t\t\t\t\t\t\t// Push values out\n\t\t\t\t\t\t\tif (self.__callback) {\n\t\t\t\t\t\t\t\tself.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\n\t\t\t\t\tvar verify = function (id) {\n\t\t\t\t\t\treturn self.__isAnimating === id;\n\t\t\t\t\t};\n\t\n\t\t\t\t\tvar completed = function (renderedFramesPerSecond, animationId, wasFinished) {\n\t\t\t\t\t\tif (animationId === self.__isAnimating) {\n\t\t\t\t\t\t\tself.__isAnimating = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (self.__didDecelerationComplete || wasFinished) {\n\t\t\t\t\t\t\tself.options.scrollingComplete();\n\t\t\t\t\t\t}\n\t\n\t\t\t\t\t\tif (self.options.zooming) {\n\t\t\t\t\t\t\tself.__computeScrollMax();\n\t\t\t\t\t\t\tif (self.__zoomComplete) {\n\t\t\t\t\t\t\t\tself.__zoomComplete();\n\t\t\t\t\t\t\t\tself.__zoomComplete = null;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\n\t\t\t\t\t// When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\n\t\t\t\t\tself.__isAnimating = core.effect.Animate.start(step, verify, completed, self.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);\n\t\t\t\t} else {\n\t\n\t\t\t\t\tself.__scheduledLeft = self.__scrollLeft = left;\n\t\t\t\t\tself.__scheduledTop = self.__scrollTop = top;\n\t\t\t\t\tself.__scheduledZoom = self.__zoomLevel = zoom;\n\t\n\t\t\t\t\t// Push values out\n\t\t\t\t\tif (self.__callback) {\n\t\t\t\t\t\tself.__callback(left, top, zoom);\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Fix max scroll ranges\n\t\t\t\t\tif (self.options.zooming) {\n\t\t\t\t\t\tself.__computeScrollMax();\n\t\t\t\t\t\tif (self.__zoomComplete) {\n\t\t\t\t\t\t\tself.__zoomComplete();\n\t\t\t\t\t\t\tself.__zoomComplete = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Recomputes scroll minimum values based on client dimensions and content dimensions.\n\t   */\n\t\t\t__computeScrollMax: function (zoomLevel) {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\tif (zoomLevel == null) {\n\t\t\t\t\tzoomLevel = self.__zoomLevel;\n\t\t\t\t}\n\t\n\t\t\t\tself.__maxScrollLeft = Math.max(self.__contentWidth * zoomLevel - self.__clientWidth, 0);\n\t\t\t\tself.__maxScrollTop = Math.max(self.__contentHeight * zoomLevel - self.__clientHeight, 0);\n\t\t\t},\n\t\n\t\t\t/*\n\t  ---------------------------------------------------------------------------\n\t  \tANIMATION (DECELERATION) SUPPORT\n\t  ---------------------------------------------------------------------------\n\t  */\n\t\n\t\t\t/**\n\t   * Called when a touch sequence end and the speed of the finger was high enough\n\t   * to switch into deceleration mode.\n\t   */\n\t\t\t__startDeceleration: function (timeStamp) {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\tif (self.options.paging) {\n\t\n\t\t\t\t\tvar scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0);\n\t\t\t\t\tvar scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0);\n\t\t\t\t\tvar clientWidth = self.__clientWidth;\n\t\t\t\t\tvar clientHeight = self.__clientHeight;\n\t\n\t\t\t\t\t// We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\n\t\t\t\t\t// Each page should have exactly the size of the client area.\n\t\t\t\t\tself.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;\n\t\t\t\t\tself.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;\n\t\t\t\t\tself.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;\n\t\t\t\t\tself.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;\n\t\t\t\t} else {\n\t\n\t\t\t\t\tself.__minDecelerationScrollLeft = 0;\n\t\t\t\t\tself.__minDecelerationScrollTop = 0;\n\t\t\t\t\tself.__maxDecelerationScrollLeft = self.__maxScrollLeft;\n\t\t\t\t\tself.__maxDecelerationScrollTop = self.__maxScrollTop;\n\t\t\t\t}\n\t\n\t\t\t\t// Wrap class method\n\t\t\t\tvar step = function (percent, now, render) {\n\t\t\t\t\tself.__stepThroughDeceleration(render);\n\t\t\t\t};\n\t\n\t\t\t\t// How much velocity is required to keep the deceleration running\n\t\t\t\tvar minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.001;\n\t\n\t\t\t\t// Detect whether it's still worth to continue animating steps\n\t\t\t\t// If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\n\t\t\t\tvar verify = function () {\n\t\t\t\t\tvar shouldContinue = Math.abs(self.__decelerationVelocityX) >= minVelocityToKeepDecelerating || Math.abs(self.__decelerationVelocityY) >= minVelocityToKeepDecelerating;\n\t\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\t\tself.__didDecelerationComplete = true;\n\t\t\t\t\t}\n\t\t\t\t\treturn shouldContinue;\n\t\t\t\t};\n\t\n\t\t\t\tvar completed = function (renderedFramesPerSecond, animationId, wasFinished) {\n\t\t\t\t\tself.__isDecelerating = false;\n\t\t\t\t\tif (self.__didDecelerationComplete) {\n\t\t\t\t\t\tself.options.scrollingComplete();\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\n\t\t\t\t\tself.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);\n\t\t\t\t};\n\t\n\t\t\t\t// Start animation and switch on flag\n\t\t\t\tself.__isDecelerating = core.effect.Animate.start(step, verify, completed);\n\t\t\t},\n\t\n\t\t\t/**\n\t   * Called on every step of the animation\n\t   *\n\t   * @param inMemory {Boolean?false} Whether to not render the current step, but keep it in memory only. Used internally only!\n\t   */\n\t\t\t__stepThroughDeceleration: function (render) {\n\t\n\t\t\t\tvar self = this;\n\t\n\t\t\t\t//\n\t\t\t\t// COMPUTE NEXT SCROLL POSITION\n\t\t\t\t//\n\t\n\t\t\t\t// Add deceleration to scroll position\n\t\t\t\tvar scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\n\t\t\t\tvar scrollTop = self.__scrollTop + self.__decelerationVelocityY;\n\t\n\t\t\t\t//\n\t\t\t\t// HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE\n\t\t\t\t//\n\t\n\t\t\t\tif (!self.options.bouncing) {\n\t\n\t\t\t\t\tvar scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);\n\t\t\t\t\tif (scrollLeftFixed !== scrollLeft) {\n\t\t\t\t\t\tscrollLeft = scrollLeftFixed;\n\t\t\t\t\t\tself.__decelerationVelocityX = 0;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tvar scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);\n\t\t\t\t\tif (scrollTopFixed !== scrollTop) {\n\t\t\t\t\t\tscrollTop = scrollTopFixed;\n\t\t\t\t\t\tself.__decelerationVelocityY = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\t\t\t// UPDATE SCROLL POSITION\n\t\t\t\t//\n\t\n\t\t\t\tif (render) {\n\t\n\t\t\t\t\tself.__publish(scrollLeft, scrollTop, self.__zoomLevel);\n\t\t\t\t} else {\n\t\n\t\t\t\t\tself.__scrollLeft = scrollLeft;\n\t\t\t\t\tself.__scrollTop = scrollTop;\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\t\t\t// SLOW DOWN\n\t\t\t\t//\n\t\n\t\t\t\t// Slow down velocity on every iteration\n\t\t\t\tif (!self.options.paging) {\n\t\n\t\t\t\t\t// This is the factor applied to every iteration of the animation\n\t\t\t\t\t// to slow down the process. This should emulate natural behavior where\n\t\t\t\t\t// objects slow down when the initiator of the movement is removed\n\t\t\t\t\tvar frictionFactor = 0.95;\n\t\n\t\t\t\t\tself.__decelerationVelocityX *= frictionFactor;\n\t\t\t\t\tself.__decelerationVelocityY *= frictionFactor;\n\t\t\t\t}\n\t\n\t\t\t\t//\n\t\t\t\t// BOUNCING SUPPORT\n\t\t\t\t//\n\t\n\t\t\t\tif (self.options.bouncing) {\n\t\n\t\t\t\t\tvar scrollOutsideX = 0;\n\t\t\t\t\tvar scrollOutsideY = 0;\n\t\n\t\t\t\t\t// This configures the amount of change applied to deceleration/acceleration when reaching boundaries\n\t\t\t\t\tvar penetrationDeceleration = self.options.penetrationDeceleration;\n\t\t\t\t\tvar penetrationAcceleration = self.options.penetrationAcceleration;\n\t\n\t\t\t\t\t// Check limits\n\t\t\t\t\tif (scrollLeft < self.__minDecelerationScrollLeft) {\n\t\t\t\t\t\tscrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\n\t\t\t\t\t} else if (scrollLeft > self.__maxDecelerationScrollLeft) {\n\t\t\t\t\t\tscrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (scrollTop < self.__minDecelerationScrollTop) {\n\t\t\t\t\t\tscrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\n\t\t\t\t\t} else if (scrollTop > self.__maxDecelerationScrollTop) {\n\t\t\t\t\t\tscrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\n\t\t\t\t\t}\n\t\n\t\t\t\t\t// Slow down until slow enough, then flip back to snap position\n\t\t\t\t\tif (scrollOutsideX !== 0) {\n\t\t\t\t\t\tif (scrollOutsideX * self.__decelerationVelocityX <= 0) {\n\t\t\t\t\t\t\tself.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\n\t\t\t\t\tif (scrollOutsideY !== 0) {\n\t\t\t\t\t\tif (scrollOutsideY * self.__decelerationVelocityY <= 0) {\n\t\t\t\t\t\t\tself.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\t\n\t\t// Copy over members to prototype\n\t\tfor (var key in members) {\n\t\t\tScroller.prototype[key] = members[key];\n\t\t}\n\t})();\n\twindow.Scroller = module.exports = Scroller;\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// scroller.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d75278c6ecfc38bd8e75","require('./src/Animate');\nScroller=require('./src/Scroller');\nmodule.exports = Scroller;\n\n\n// WEBPACK FOOTER //\n// ./index.js","/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\n\n/**\n * Generic animation class with support for dropped frames both optional easing and duration.\n *\n * Optional duration is useful when the lifetime is defined by another condition than time\n * e.g. speed of an animating object, etc.\n *\n * Dropped frame logic allows to keep using the same updater logic independent from the actual\n * rendering. This eases a lot of cases where it might be pretty complex to break down a state\n * based on the pure time difference.\n */\nfunction Animate() {\n\tvar time = Date.now || function() {\n\t\treturn +new Date();\n\t};\n\tvar desiredFrames = 60;\n\tvar millisecondsPerSecond = 1000;\n\tvar running = {};\n\tvar counter = 1;\n\n\t// Create namespaces\n\n\n\tcore = { effect : {} };\n\n   // var core = { effect : {} };\n\tcore.effect.Animate = {\n\n\t\t/**\n\t\t * A requestAnimationFrame wrapper / polyfill.\n\t\t *\n\t\t * @param callback {Function} The callback to be invoked before the next repaint.\n\t\t * @param root {HTMLElement} The root element for the repaint\n\t\t */\n\t\trequestAnimationFrame: (function() {\n\n\t\t\t// Check for request animation Frame support\n\t\t\tvar requestFrame = global.requestAnimationFrame || global.webkitRequestAnimationFrame || global.mozRequestAnimationFrame || global.oRequestAnimationFrame;\n\t\t\tvar isNative = !!requestFrame;\n\n\t\t\tif (requestFrame && !/requestAnimationFrame\\(\\)\\s*\\{\\s*\\[native code\\]\\s*\\}/i.test(requestFrame.toString())) {\n\t\t\t\tisNative = false;\n\t\t\t}\n\n\t\t\tif (isNative) {\n\t\t\t\treturn function(callback, root) {\n\t\t\t\t\trequestFrame(callback, root)\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar TARGET_FPS = 60;\n\t\t\tvar requests = {};\n\t\t\tvar requestCount = 0;\n\t\t\tvar rafHandle = 1;\n\t\t\tvar intervalHandle = null;\n\t\t\tvar lastActive = +new Date();\n\n\t\t\treturn function(callback, root) {\n\t\t\t\tvar callbackHandle = rafHandle++;\n\n\t\t\t\t// Store callback\n\t\t\t\trequests[callbackHandle] = callback;\n\t\t\t\trequestCount++;\n\n\t\t\t\t// Create timeout at first request\n\t\t\t\tif (intervalHandle === null) {\n\n\t\t\t\t\tintervalHandle = setInterval(function() {\n\n\t\t\t\t\t\tvar time = +new Date();\n\t\t\t\t\t\tvar currentRequests = requests;\n\n\t\t\t\t\t\t// Reset data structure before executing callbacks\n\t\t\t\t\t\trequests = {};\n\t\t\t\t\t\trequestCount = 0;\n\n\t\t\t\t\t\tfor(var key in currentRequests) {\n\t\t\t\t\t\t\tif (currentRequests.hasOwnProperty(key)) {\n\t\t\t\t\t\t\t\tcurrentRequests[key](time);\n\t\t\t\t\t\t\t\tlastActive = time;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Disable the timeout when nothing happens for a certain\n\t\t\t\t\t\t// period of time\n\t\t\t\t\t\tif (time - lastActive > 2500) {\n\t\t\t\t\t\t\tclearInterval(intervalHandle);\n\t\t\t\t\t\t\tintervalHandle = null;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}, 1000 / TARGET_FPS);\n\t\t\t\t}\n\n\t\t\t\treturn callbackHandle;\n\t\t\t};\n\n\t\t})(),\n\n\n\t\t/**\n\t\t * Stops the given animation.\n\t\t *\n\t\t * @param id {Integer} Unique animation ID\n\t\t * @return {Boolean} Whether the animation was stopped (aka, was running before)\n\t\t */\n\t\tstop: function(id) {\n\t\t\tvar cleared = running[id] != null;\n\t\t\tif (cleared) {\n\t\t\t\trunning[id] = null;\n\t\t\t}\n\n\t\t\treturn cleared;\n\t\t},\n\n\n\t\t/**\n\t\t * Whether the given animation is still running.\n\t\t *\n\t\t * @param id {Integer} Unique animation ID\n\t\t * @return {Boolean} Whether the animation is still running\n\t\t */\n\t\tisRunning: function(id) {\n\t\t\treturn running[id] != null;\n\t\t},\n\n\n\t\t/**\n\t\t * Start the animation.\n\t\t *\n\t\t * @param stepCallback {Function} Pointer to function which is executed on every step.\n\t\t *   Signature of the method should be `function(percent, now, virtual) { return continueWithAnimation; }`\n\t\t * @param verifyCallback {Function} Executed before every animation step.\n\t\t *   Signature of the method should be `function() { return continueWithAnimation; }`\n\t\t * @param completedCallback {Function}\n\t\t *   Signature of the method should be `function(droppedFrames, finishedAnimation) {}`\n\t\t * @param duration {Integer} Milliseconds to run the animation\n\t\t * @param easingMethod {Function} Pointer to easing function\n\t\t *   Signature of the method should be `function(percent) { return modifiedValue; }`\n\t\t * @param root {Element ? document.body} Render root, when available. Used for internal\n\t\t *   usage of requestAnimationFrame.\n\t\t * @return {Integer} Identifier of animation. Can be used to stop it any time.\n\t\t */\n\t\tstart: function(stepCallback, verifyCallback, completedCallback, duration, easingMethod, root) {\n\n\t\t\tvar start = time();\n\t\t\tvar lastFrame = start;\n\t\t\tvar percent = 0;\n\t\t\tvar dropCounter = 0;\n\t\t\tvar id = counter++;\n\n\t\t\tif (!root) {\n\t\t\t\troot = document.body;\n\t\t\t}\n\n\t\t\t// Compacting running db automatically every few new animations\n\t\t\tif (id % 20 === 0) {\n\t\t\t\tvar newRunning = {};\n\t\t\t\tfor (var usedId in running) {\n\t\t\t\t\tnewRunning[usedId] = true;\n\t\t\t\t}\n\t\t\t\trunning = newRunning;\n\t\t\t}\n\n\t\t\t// This is the internal step method which is called every few milliseconds\n\t\t\tvar step = function(virtual) {\n\n\t\t\t\t// Normalize virtual value\n\t\t\t\tvar render = virtual !== true;\n\n\t\t\t\t// Get current time\n\t\t\t\tvar now = time();\n\n\t\t\t\t// Verification is executed before next animation step\n\t\t\t\tif (!running[id] || (verifyCallback && !verifyCallback(id))) {\n\n\t\t\t\t\trunning[id] = null;\n\t\t\t\t\tcompletedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, false);\n\t\t\t\t\treturn;\n\n\t\t\t\t}\n\n\t\t\t\t// For the current rendering to apply let's update omitted steps in memory.\n\t\t\t\t// This is important to bring internal state variables up-to-date with progress in time.\n\t\t\t\tif (render) {\n\n\t\t\t\t\tvar droppedFrames = Math.round((now - lastFrame) / (millisecondsPerSecond / desiredFrames)) - 1;\n\t\t\t\t\tfor (var j = 0; j < Math.min(droppedFrames, 4); j++) {\n\t\t\t\t\t\tstep(true);\n\t\t\t\t\t\tdropCounter++;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\t// Compute percent value\n\t\t\t\tif (duration) {\n\t\t\t\t\tpercent = (now - start) / duration;\n\t\t\t\t\tif (percent > 1) {\n\t\t\t\t\t\tpercent = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Execute step callback, then...\n\t\t\t\tvar value = easingMethod ? easingMethod(percent) : percent;\n\t\t\t\tif ((stepCallback(value, now, render) === false || percent === 1) && render) {\n\t\t\t\t\trunning[id] = null;\n\t\t\t\t\tcompletedCallback && completedCallback(desiredFrames - (dropCounter / ((now - start) / millisecondsPerSecond)), id, percent === 1 || duration == null);\n\t\t\t\t} else if (render) {\n\t\t\t\t\tlastFrame = now;\n\t\t\t\t\tcore.effect.Animate.requestAnimationFrame(step, root);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Mark as running\n\t\t\trunning[id] = true;\n\n\t\t\t// Init first step\n\t\t\tcore.effect.Animate.requestAnimationFrame(step, root);\n\n\t\t\t// Return unique animation ID\n\t\t\treturn id;\n\t\t}\n\t};\n\treturn global.core;\n}\nwindow.core=Animate();\n\n\n// WEBPACK FOOTER //\n// ./src/Animate.js","/*\n * Scroller\n * http://github.com/zynga/scroller\n *\n * Copyright 2011, Zynga Inc.\n * Licensed under the MIT License.\n * https://raw.github.com/zynga/scroller/master/MIT-LICENSE.txt\n *\n * Based on the work of: Unify Project (unify-project.org)\n * http://unify-project.org\n * Copyright 2011, Deutsche Telekom AG\n * License: MIT + Apache (V2)\n */\n\nvar Scroller;\n(function() {\n\tvar NOOP = function(){};\n\n\t/**\n\t * A pure logic 'component' for 'virtual' scrolling/zooming.\n\t */\n\tScroller = function(callback, options) {\n\n\n\t\tthis.__callback = callback;\n\n\t\tthis.options = {\n\n\t\t\t/** Enable scrolling on x-axis */\n\t\t\tscrollingX: true,\n\n\t\t\t/** Enable scrolling on y-axis */\n\t\t\tscrollingY: true,\n\n\t\t\t/** Enable animations for deceleration, snap back, zooming and scrolling */\n\t\t\tanimating: true,\n\n\t\t\t/** duration for animations triggered by scrollTo/zoomTo */\n\t\t\tanimationDuration: 250,\n\n\t\t\t/** Enable bouncing (content can be slowly moved outside and jumps back after releasing) */\n\t\t\tbouncing: true,\n\n\t\t\t/** Enable locking to the main axis if user moves only slightly on one of them at start */\n\t\t\tlocking: true,\n\n\t\t\t/** Enable pagination mode (switching between full page content panes) */\n\t\t\tpaging: false,\n\n\t\t\t/** Enable snapping of content to a configured pixel grid */\n\t\t\tsnapping: false,\n\n\t\t\t/** Enable zooming of content via API, fingers and mouse wheel */\n\t\t\tzooming: false,\n\n\t\t\t/** Minimum zoom level */\n\t\t\tminZoom: 0.5,\n\n\t\t\t/** Maximum zoom level */\n\t\t\tmaxZoom: 3,\n\n\t\t\t/** Multiply or decrease scrolling speed **/\n\t\t\tspeedMultiplier: 1,\n\n\t\t\t/** Callback that is fired on the later of touch end or deceleration end,\n\t\t\t\tprovided that another scrolling action has not begun. Used to know\n\t\t\t\twhen to fade out a scrollbar. */\n\t\t\tscrollingComplete: NOOP,\n\n\t\t\t/** This configures the amount of change applied to deceleration when reaching boundaries  **/\n            penetrationDeceleration : 0.03,\n\n            /** This configures the amount of change applied to acceleration when reaching boundaries  **/\n            penetrationAcceleration : 0.08\n\n\t\t};\n\n\t\tfor (var key in options) {\n\t\t\tthis.options[key] = options[key];\n\t\t}\n\n\t};\n\n\n\t// Easing Equations (c) 2003 Robert Penner, all rights reserved.\n\t// Open source under the BSD License.\n\n\t/**\n\t * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\n\t**/\n\tvar easeOutCubic = function(pos) {\n\t\treturn (Math.pow((pos - 1), 3) + 1);\n\t};\n\n\t/**\n\t * @param pos {Number} position between 0 (start of effect) and 1 (end of effect)\n\t**/\n\tvar easeInOutCubic = function(pos) {\n\t\tif ((pos /= 0.5) < 1) {\n\t\t\treturn 0.5 * Math.pow(pos, 3);\n\t\t}\n\n\t\treturn 0.5 * (Math.pow((pos - 2), 3) + 2);\n\t};\n\n\n\tvar members = {\n\n\t\t/*\n\t\t---------------------------------------------------------------------------\n\t\t\tINTERNAL FIELDS :: STATUS\n\t\t---------------------------------------------------------------------------\n\t\t*/\n\n\t\t/** {Boolean} Whether only a single finger is used in touch handling */\n\t\t__isSingleTouch: false,\n\n\t\t/** {Boolean} Whether a touch event sequence is in progress */\n\t\t__isTracking: false,\n\n\t\t/** {Boolean} Whether a deceleration animation went to completion. */\n\t\t__didDecelerationComplete: false,\n\n\t\t/**\n\t\t * {Boolean} Whether a gesture zoom/rotate event is in progress. Activates when\n\t\t * a gesturestart event happens. This has higher priority than dragging.\n\t\t */\n\t\t__isGesturing: false,\n\n\t\t/**\n\t\t * {Boolean} Whether the user has moved by such a distance that we have enabled\n\t\t * dragging mode. Hint: It's only enabled after some pixels of movement to\n\t\t * not interrupt with clicks etc.\n\t\t */\n\t\t__isDragging: false,\n\n\t\t/**\n\t\t * {Boolean} Not touching and dragging anymore, and smoothly animating the\n\t\t * touch sequence using deceleration.\n\t\t */\n\t\t__isDecelerating: false,\n\n\t\t/**\n\t\t * {Boolean} Smoothly animating the currently configured change\n\t\t */\n\t\t__isAnimating: false,\n\n\n\n\t\t/*\n\t\t---------------------------------------------------------------------------\n\t\t\tINTERNAL FIELDS :: DIMENSIONS\n\t\t---------------------------------------------------------------------------\n\t\t*/\n\n\t\t/** {Integer} Available outer left position (from document perspective) */\n\t\t__clientLeft: 0,\n\n\t\t/** {Integer} Available outer top position (from document perspective) */\n\t\t__clientTop: 0,\n\n\t\t/** {Integer} Available outer width */\n\t\t__clientWidth: 0,\n\n\t\t/** {Integer} Available outer height */\n\t\t__clientHeight: 0,\n\n\t\t/** {Integer} Outer width of content */\n\t\t__contentWidth: 0,\n\n\t\t/** {Integer} Outer height of content */\n\t\t__contentHeight: 0,\n\n\t\t/** {Integer} Snapping width for content */\n\t\t__snapWidth: 100,\n\n\t\t/** {Integer} Snapping height for content */\n\t\t__snapHeight: 100,\n\n\t\t/** {Integer} Height to assign to refresh area */\n\t\t__refreshHeight: null,\n\n\t\t/** {Boolean} Whether the refresh process is enabled when the event is released now */\n\t\t__refreshActive: false,\n\n\t\t/** {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release */\n\t\t__refreshActivate: null,\n\n\t\t/** {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled */\n\t\t__refreshDeactivate: null,\n\n\t\t/** {Function} Callback to execute to start the actual refresh. Call {@link #refreshFinish} when done */\n\t\t__refreshStart: null,\n\n\t\t/** {Number} Zoom level */\n\t\t__zoomLevel: 1,\n\n\t\t/** {Number} Scroll position on x-axis */\n\t\t__scrollLeft: 0,\n\n\t\t/** {Number} Scroll position on y-axis */\n\t\t__scrollTop: 0,\n\n\t\t/** {Integer} Maximum allowed scroll position on x-axis */\n\t\t__maxScrollLeft: 0,\n\n\t\t/** {Integer} Maximum allowed scroll position on y-axis */\n\t\t__maxScrollTop: 0,\n\n\t\t/* {Number} Scheduled left position (final position when animating) */\n\t\t__scheduledLeft: 0,\n\n\t\t/* {Number} Scheduled top position (final position when animating) */\n\t\t__scheduledTop: 0,\n\n\t\t/* {Number} Scheduled zoom level (final scale when animating) */\n\t\t__scheduledZoom: 0,\n\n\n\n\t\t/*\n\t\t---------------------------------------------------------------------------\n\t\t\tINTERNAL FIELDS :: LAST POSITIONS\n\t\t---------------------------------------------------------------------------\n\t\t*/\n\n\t\t/** {Number} Left position of finger at start */\n\t\t__lastTouchLeft: null,\n\n\t\t/** {Number} Top position of finger at start */\n\t\t__lastTouchTop: null,\n\n\t\t/** {Date} Timestamp of last move of finger. Used to limit tracking range for deceleration speed. */\n\t\t__lastTouchMove: null,\n\n\t\t/** {Array} List of positions, uses three indexes for each state: left, top, timestamp */\n\t\t__positions: null,\n\n\n\n\t\t/*\n\t\t---------------------------------------------------------------------------\n\t\t\tINTERNAL FIELDS :: DECELERATION SUPPORT\n\t\t---------------------------------------------------------------------------\n\t\t*/\n\n\t\t/** {Integer} Minimum left scroll position during deceleration */\n\t\t__minDecelerationScrollLeft: null,\n\n\t\t/** {Integer} Minimum top scroll position during deceleration */\n\t\t__minDecelerationScrollTop: null,\n\n\t\t/** {Integer} Maximum left scroll position during deceleration */\n\t\t__maxDecelerationScrollLeft: null,\n\n\t\t/** {Integer} Maximum top scroll position during deceleration */\n\t\t__maxDecelerationScrollTop: null,\n\n\t\t/** {Number} Current factor to modify horizontal scroll position with on every step */\n\t\t__decelerationVelocityX: null,\n\n\t\t/** {Number} Current factor to modify vertical scroll position with on every step */\n\t\t__decelerationVelocityY: null,\n\n\n\n\t\t/*\n\t\t---------------------------------------------------------------------------\n\t\t\tPUBLIC API\n\t\t---------------------------------------------------------------------------\n\t\t*/\n\n\t\t/**\n\t\t * Configures the dimensions of the client (outer) and content (inner) elements.\n\t\t * Requires the available space for the outer element and the outer size of the inner element.\n\t\t * All values which are falsy (null or zero etc.) are ignored and the old value is kept.\n\t\t *\n\t\t * @param clientWidth {Integer ? null} Inner width of outer element\n\t\t * @param clientHeight {Integer ? null} Inner height of outer element\n\t\t * @param contentWidth {Integer ? null} Outer width of inner element\n\t\t * @param contentHeight {Integer ? null} Outer height of inner element\n\t\t */\n\t\tsetDimensions: function(clientWidth, clientHeight, contentWidth, contentHeight) {\n\n\t\t\tvar self = this;\n\n\t\t\t// Only update values which are defined\n\t\t\tif (clientWidth === +clientWidth) {\n\t\t\t\tself.__clientWidth = clientWidth;\n\t\t\t}\n\n\t\t\tif (clientHeight === +clientHeight) {\n\t\t\t\tself.__clientHeight = clientHeight;\n\t\t\t}\n\n\t\t\tif (contentWidth === +contentWidth) {\n\t\t\t\tself.__contentWidth = contentWidth;\n\t\t\t}\n\n\t\t\tif (contentHeight === +contentHeight) {\n\t\t\t\tself.__contentHeight = contentHeight;\n\t\t\t}\n\n\t\t\t// Refresh maximums\n\t\t\tself.__computeScrollMax();\n\n\t\t\t// Refresh scroll position\n\t\t\tself.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n\n\t\t},\n\n\n\t\t/**\n\t\t * Sets the client coordinates in relation to the document.\n\t\t *\n\t\t * @param left {Integer ? 0} Left position of outer element\n\t\t * @param top {Integer ? 0} Top position of outer element\n\t\t */\n\t\tsetPosition: function(left, top) {\n\n\t\t\tvar self = this;\n\n\t\t\tself.__clientLeft = left || 0;\n\t\t\tself.__clientTop = top || 0;\n\n\t\t},\n\n\n\t\t/**\n\t\t * Configures the snapping (when snapping is active)\n\t\t *\n\t\t * @param width {Integer} Snapping width\n\t\t * @param height {Integer} Snapping height\n\t\t */\n\t\tsetSnapSize: function(width, height) {\n\n\t\t\tvar self = this;\n\n\t\t\tself.__snapWidth = width;\n\t\t\tself.__snapHeight = height;\n\n\t\t},\n\n\n\t\t/**\n\t\t * Activates pull-to-refresh. A special zone on the top of the list to start a list refresh whenever\n\t\t * the user event is released during visibility of this zone. This was introduced by some apps on iOS like\n\t\t * the official Twitter client.\n\t\t *\n\t\t * @param height {Integer} Height of pull-to-refresh zone on top of rendered list\n\t\t * @param activateCallback {Function} Callback to execute on activation. This is for signalling the user about a refresh is about to happen when he release.\n\t\t * @param deactivateCallback {Function} Callback to execute on deactivation. This is for signalling the user about the refresh being cancelled.\n\t\t * @param startCallback {Function} Callback to execute to start the real async refresh action. Call {@link #finishPullToRefresh} after finish of refresh.\n\t\t */\n\t\tactivatePullToRefresh: function(height, activateCallback, deactivateCallback, startCallback) {\n\n\t\t\tvar self = this;\n\n\t\t\tself.__refreshHeight = height;\n\t\t\tself.__refreshActivate = activateCallback;\n\t\t\tself.__refreshDeactivate = deactivateCallback;\n\t\t\tself.__refreshStart = startCallback;\n\n\t\t},\n\n\n\t\t/**\n\t\t * Starts pull-to-refresh manually.\n\t\t */\n\t\ttriggerPullToRefresh: function() {\n\t\t\t// Use publish instead of scrollTo to allow scrolling to out of boundary position\n\t\t\t// We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n\t\t\tthis.__publish(this.__scrollLeft, -this.__refreshHeight, this.__zoomLevel, true);\n\n\t\t\tif (this.__refreshStart) {\n\t\t\t\tthis.__refreshStart();\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * Signalizes that pull-to-refresh is finished.\n\t\t */\n\t\tfinishPullToRefresh: function() {\n\n\t\t\tvar self = this;\n\n\t\t\tself.__refreshActive = false;\n\t\t\tif (self.__refreshDeactivate) {\n\t\t\t\tself.__refreshDeactivate();\n\t\t\t}\n\n\t\t\tself.scrollTo(self.__scrollLeft, self.__scrollTop, true);\n\n\t\t},\n\n\n\t\t/**\n\t\t * Returns the scroll position and zooming values\n\t\t *\n\t\t * @return {Map} `left` and `top` scroll position and `zoom` level\n\t\t */\n\t\tgetValues: function() {\n\n\t\t\tvar self = this;\n\n\t\t\treturn {\n\t\t\t\tleft: self.__scrollLeft,\n\t\t\t\ttop: self.__scrollTop,\n\t\t\t\tzoom: self.__zoomLevel\n\t\t\t};\n\n\t\t},\n\n\n\t\t/**\n\t\t * Returns the maximum scroll values\n\t\t *\n\t\t * @return {Map} `left` and `top` maximum scroll values\n\t\t */\n\t\tgetScrollMax: function() {\n\n\t\t\tvar self = this;\n\n\t\t\treturn {\n\t\t\t\tleft: self.__maxScrollLeft,\n\t\t\t\ttop: self.__maxScrollTop\n\t\t\t};\n\n\t\t},\n\n\n\t\t/**\n\t\t * Zooms to the given level. Supports optional animation. Zooms\n\t\t * the center when no coordinates are given.\n\t\t *\n\t\t * @param level {Number} Level to zoom to\n\t\t * @param animate {Boolean ? false} Whether to use animation\n\t\t * @param originLeft {Number ? null} Zoom in at given left coordinate\n\t\t * @param originTop {Number ? null} Zoom in at given top coordinate\n\t\t * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n\t\t */\n\t\tzoomTo: function(level, animate, originLeft, originTop, callback) {\n\n\t\t\tvar self = this;\n\n\t\t\tif (!self.options.zooming) {\n\t\t\t\tthrow new Error(\"Zooming is not enabled!\");\n\t\t\t}\n\n\t\t\t// Add callback if exists\n\t\t\tif(callback) {\n\t\t\t\tself.__zoomComplete = callback;\n\t\t\t}\n\n\t\t\t// Stop deceleration\n\t\t\tif (self.__isDecelerating) {\n\t\t\t\tcore.effect.Animate.stop(self.__isDecelerating);\n\t\t\t\tself.__isDecelerating = false;\n\t\t\t}\n\n\t\t\tvar oldLevel = self.__zoomLevel;\n\n\t\t\t// Normalize input origin to center of viewport if not defined\n\t\t\tif (originLeft == null) {\n\t\t\t\toriginLeft = self.__clientWidth / 2;\n\t\t\t}\n\n\t\t\tif (originTop == null) {\n\t\t\t\toriginTop = self.__clientHeight / 2;\n\t\t\t}\n\n\t\t\t// Limit level according to configuration\n\t\t\tlevel = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);\n\n\t\t\t// Recompute maximum values while temporary tweaking maximum scroll ranges\n\t\t\tself.__computeScrollMax(level);\n\n\t\t\t// Recompute left and top coordinates based on new zoom level\n\t\t\tvar left = ((originLeft + self.__scrollLeft) * level / oldLevel) - originLeft;\n\t\t\tvar top = ((originTop + self.__scrollTop) * level / oldLevel) - originTop;\n\n\t\t\t// Limit x-axis\n\t\t\tif (left > self.__maxScrollLeft) {\n\t\t\t\tleft = self.__maxScrollLeft;\n\t\t\t} else if (left < 0) {\n\t\t\t\tleft = 0;\n\t\t\t}\n\n\t\t\t// Limit y-axis\n\t\t\tif (top > self.__maxScrollTop) {\n\t\t\t\ttop = self.__maxScrollTop;\n\t\t\t} else if (top < 0) {\n\t\t\t\ttop = 0;\n\t\t\t}\n\n\t\t\t// Push values out\n\t\t\tself.__publish(left, top, level, animate);\n\n\t\t},\n\n\n\t\t/**\n\t\t * Zooms the content by the given factor.\n\t\t *\n\t\t * @param factor {Number} Zoom by given factor\n\t\t * @param animate {Boolean ? false} Whether to use animation\n\t\t * @param originLeft {Number ? 0} Zoom in at given left coordinate\n\t\t * @param originTop {Number ? 0} Zoom in at given top coordinate\n\t\t * @param callback {Function ? null} A callback that gets fired when the zoom is complete.\n\t\t */\n\t\tzoomBy: function(factor, animate, originLeft, originTop, callback) {\n\n\t\t\tvar self = this;\n\n\t\t\tself.zoomTo(self.__zoomLevel * factor, animate, originLeft, originTop, callback);\n\n\t\t},\n\n\n\t\t/**\n\t\t * Scrolls to the given position. Respect limitations and snapping automatically.\n\t\t *\n\t\t * @param left {Number?null} Horizontal scroll position, keeps current if value is <code>null</code>\n\t\t * @param top {Number?null} Vertical scroll position, keeps current if value is <code>null</code>\n\t\t * @param animate {Boolean?false} Whether the scrolling should happen using an animation\n\t\t * @param zoom {Number?null} Zoom level to go to\n\t\t */\n\t\tscrollTo: function(left, top, animate, zoom) {\n\n\t\t\tvar self = this;\n\n\t\t\t// Stop deceleration\n\t\t\tif (self.__isDecelerating) {\n\t\t\t\tcore.effect.Animate.stop(self.__isDecelerating);\n\t\t\t\tself.__isDecelerating = false;\n\t\t\t}\n\n\t\t\t// Correct coordinates based on new zoom level\n\t\t\tif (zoom != null && zoom !== self.__zoomLevel) {\n\n\t\t\t\tif (!self.options.zooming) {\n\t\t\t\t\tthrow new Error(\"Zooming is not enabled!\");\n\t\t\t\t}\n\n\t\t\t\tleft *= zoom;\n\t\t\t\ttop *= zoom;\n\n\t\t\t\t// Recompute maximum values while temporary tweaking maximum scroll ranges\n\t\t\t\tself.__computeScrollMax(zoom);\n\n\t\t\t} else {\n\n\t\t\t\t// Keep zoom when not defined\n\t\t\t\tzoom = self.__zoomLevel;\n\n\t\t\t}\n\n\t\t\tif (!self.options.scrollingX) {\n\n\t\t\t\tleft = self.__scrollLeft;\n\n\t\t\t} else {\n\n\t\t\t\tif (self.options.paging) {\n\t\t\t\t\tleft = Math.round(left / self.__clientWidth) * self.__clientWidth;\n\t\t\t\t} else if (self.options.snapping) {\n\t\t\t\t\tleft = Math.round(left / self.__snapWidth) * self.__snapWidth;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tif (!self.options.scrollingY) {\n\n\t\t\t\ttop = self.__scrollTop;\n\n\t\t\t} else {\n\n\t\t\t\tif (self.options.paging) {\n\t\t\t\t\ttop = Math.round(top / self.__clientHeight) * self.__clientHeight;\n\t\t\t\t} else if (self.options.snapping) {\n\t\t\t\t\ttop = Math.round(top / self.__snapHeight) * self.__snapHeight;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Limit for allowed ranges\n\t\t\tleft = Math.max(Math.min(self.__maxScrollLeft, left), 0);\n\t\t\ttop = Math.max(Math.min(self.__maxScrollTop, top), 0);\n\n\t\t\t// Don't animate when no change detected, still call publish to make sure\n\t\t\t// that rendered position is really in-sync with internal data\n\t\t\tif (left === self.__scrollLeft && top === self.__scrollTop) {\n\t\t\t\tanimate = false;\n\t\t\t}\n\n\t\t\t// Publish new values\n\t\t\tif (!self.__isTracking) {\n        self.__publish(left, top, zoom, animate);\n      }\n\n\t\t},\n\n\n\t\t/**\n\t\t * Scroll by the given offset\n\t\t *\n\t\t * @param left {Number ? 0} Scroll x-axis by given offset\n\t\t * @param top {Number ? 0} Scroll x-axis by given offset\n\t\t * @param animate {Boolean ? false} Whether to animate the given change\n\t\t */\n\t\tscrollBy: function(left, top, animate) {\n\n\t\t\tvar self = this;\n\n\t\t\tvar startLeft = self.__isAnimating ? self.__scheduledLeft : self.__scrollLeft;\n\t\t\tvar startTop = self.__isAnimating ? self.__scheduledTop : self.__scrollTop;\n\n\t\t\tself.scrollTo(startLeft + (left || 0), startTop + (top || 0), animate);\n\n\t\t},\n\n\n\n\t\t/*\n\t\t---------------------------------------------------------------------------\n\t\t\tEVENT CALLBACKS\n\t\t---------------------------------------------------------------------------\n\t\t*/\n\n\t\t/**\n\t\t * Mouse wheel handler for zooming support\n\t\t */\n\t\tdoMouseZoom: function(wheelDelta, timeStamp, pageX, pageY) {\n\n\t\t\tvar self = this;\n\t\t\tvar change = wheelDelta > 0 ? 0.97 : 1.03;\n\n\t\t\treturn self.zoomTo(self.__zoomLevel * change, false, pageX - self.__clientLeft, pageY - self.__clientTop);\n\n\t\t},\n\n\n\t\t/**\n\t\t * Touch start handler for scrolling support\n\t\t */\n\t\tdoTouchStart: function(touches, timeStamp) {\n\n\t\t\t// Array-like check is enough here\n\t\t\tif (touches.length == null) {\n\t\t\t\tthrow new Error(\"Invalid touch list: \" + touches);\n\t\t\t}\n\n\t\t\tif (timeStamp instanceof Date) {\n\t\t\t\ttimeStamp = timeStamp.valueOf();\n\t\t\t}\n\t\t\tif (typeof timeStamp !== \"number\") {\n\t\t\t\tthrow new Error(\"Invalid timestamp value: \" + timeStamp);\n\t\t\t}\n\n\t\t\tvar self = this;\n\n\t\t\t// Reset interruptedAnimation flag\n\t\t\tself.__interruptedAnimation = true;\n\n\t\t\t// Stop deceleration\n\t\t\tif (self.__isDecelerating) {\n\t\t\t\tcore.effect.Animate.stop(self.__isDecelerating);\n\t\t\t\tself.__isDecelerating = false;\n\t\t\t\tself.__interruptedAnimation = true;\n\t\t\t}\n\n\t\t\t// Stop animation\n\t\t\tif (self.__isAnimating) {\n\t\t\t\tcore.effect.Animate.stop(self.__isAnimating);\n\t\t\t\tself.__isAnimating = false;\n\t\t\t\tself.__interruptedAnimation = true;\n\t\t\t}\n\n\t\t\t// Use center point when dealing with two fingers\n\t\t\tvar currentTouchLeft, currentTouchTop;\n\t\t\tvar isSingleTouch = touches.length === 1;\n\t\t\tif (isSingleTouch) {\n\t\t\t\tcurrentTouchLeft = touches[0].pageX;\n\t\t\t\tcurrentTouchTop = touches[0].pageY;\n\t\t\t} else {\n\t\t\t\tcurrentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n\t\t\t\tcurrentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n\t\t\t}\n\n\t\t\t// Store initial positions\n\t\t\tself.__initialTouchLeft = currentTouchLeft;\n\t\t\tself.__initialTouchTop = currentTouchTop;\n\n\t\t\t// Store current zoom level\n\t\t\tself.__zoomLevelStart = self.__zoomLevel;\n\n\t\t\t// Store initial touch positions\n\t\t\tself.__lastTouchLeft = currentTouchLeft;\n\t\t\tself.__lastTouchTop = currentTouchTop;\n\n\t\t\t// Store initial move time stamp\n\t\t\tself.__lastTouchMove = timeStamp;\n\n\t\t\t// Reset initial scale\n\t\t\tself.__lastScale = 1;\n\n\t\t\t// Reset locking flags\n\t\t\tself.__enableScrollX = !isSingleTouch && self.options.scrollingX;\n\t\t\tself.__enableScrollY = !isSingleTouch && self.options.scrollingY;\n\n\t\t\t// Reset tracking flag\n\t\t\tself.__isTracking = true;\n\n\t\t\t// Reset deceleration complete flag\n\t\t\tself.__didDecelerationComplete = false;\n\n\t\t\t// Dragging starts directly with two fingers, otherwise lazy with an offset\n\t\t\tself.__isDragging = !isSingleTouch;\n\n\t\t\t// Some features are disabled in multi touch scenarios\n\t\t\tself.__isSingleTouch = isSingleTouch;\n\n\t\t\t// Clearing data structure\n\t\t\tself.__positions = [];\n\n\t\t},\n\n\n\t\t/**\n\t\t * Touch move handler for scrolling support\n\t\t */\n\t\tdoTouchMove: function(touches, timeStamp, scale) {\n\n\t\t\t// Array-like check is enough here\n\t\t\tif (touches.length == null) {\n\t\t\t\tthrow new Error(\"Invalid touch list: \" + touches);\n\t\t\t}\n\n\t\t\tif (timeStamp instanceof Date) {\n\t\t\t\ttimeStamp = timeStamp.valueOf();\n\t\t\t}\n\t\t\tif (typeof timeStamp !== \"number\") {\n\t\t\t\tthrow new Error(\"Invalid timestamp value: \" + timeStamp);\n\t\t\t}\n\n\t\t\tvar self = this;\n\n\t\t\t// Ignore event when tracking is not enabled (event might be outside of element)\n\t\t\tif (!self.__isTracking) {\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\tvar currentTouchLeft, currentTouchTop;\n\n\t\t\t// Compute move based around of center of fingers\n\t\t\tif (touches.length === 2) {\n\t\t\t\tcurrentTouchLeft = Math.abs(touches[0].pageX + touches[1].pageX) / 2;\n\t\t\t\tcurrentTouchTop = Math.abs(touches[0].pageY + touches[1].pageY) / 2;\n\t\t\t} else {\n\t\t\t\tcurrentTouchLeft = touches[0].pageX;\n\t\t\t\tcurrentTouchTop = touches[0].pageY;\n\t\t\t}\n\n\t\t\tvar positions = self.__positions;\n\n\t\t\t// Are we already is dragging mode?\n\t\t\tif (self.__isDragging) {\n\n\t\t\t\t// Compute move distance\n\t\t\t\tvar moveX = currentTouchLeft - self.__lastTouchLeft;\n\t\t\t\tvar moveY = currentTouchTop - self.__lastTouchTop;\n\n\t\t\t\t// Read previous scroll position and zooming\n\t\t\t\tvar scrollLeft = self.__scrollLeft;\n\t\t\t\tvar scrollTop = self.__scrollTop;\n\t\t\t\tvar level = self.__zoomLevel;\n\n\t\t\t\t// Work with scaling\n\t\t\t\tif (scale != null && self.options.zooming) {\n\n\t\t\t\t\tvar oldLevel = level;\n\n\t\t\t\t\t// Recompute level based on previous scale and new scale\n\t\t\t\t\tlevel = level / self.__lastScale * scale;\n\n\t\t\t\t\t// Limit level according to configuration\n\t\t\t\t\tlevel = Math.max(Math.min(level, self.options.maxZoom), self.options.minZoom);\n\n\t\t\t\t\t// Only do further compution when change happened\n\t\t\t\t\tif (oldLevel !== level) {\n\n\t\t\t\t\t\t// Compute relative event position to container\n\t\t\t\t\t\tvar currentTouchLeftRel = currentTouchLeft - self.__clientLeft;\n\t\t\t\t\t\tvar currentTouchTopRel = currentTouchTop - self.__clientTop;\n\n\t\t\t\t\t\t// Recompute left and top coordinates based on new zoom level\n\t\t\t\t\t\tscrollLeft = ((currentTouchLeftRel + scrollLeft) * level / oldLevel) - currentTouchLeftRel;\n\t\t\t\t\t\tscrollTop = ((currentTouchTopRel + scrollTop) * level / oldLevel) - currentTouchTopRel;\n\n\t\t\t\t\t\t// Recompute max scroll values\n\t\t\t\t\t\tself.__computeScrollMax(level);\n\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (self.__enableScrollX) {\n\n\t\t\t\t\tscrollLeft -= moveX * this.options.speedMultiplier;\n\t\t\t\t\tvar maxScrollLeft = self.__maxScrollLeft;\n\n\t\t\t\t\tif (scrollLeft > maxScrollLeft || scrollLeft < 0) {\n\n\t\t\t\t\t\t// Slow down on the edges\n\t\t\t\t\t\tif (self.options.bouncing) {\n\n\t\t\t\t\t\t\tscrollLeft += (moveX / 2  * this.options.speedMultiplier);\n\n\t\t\t\t\t\t} else if (scrollLeft > maxScrollLeft) {\n\n\t\t\t\t\t\t\tscrollLeft = maxScrollLeft;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tscrollLeft = 0;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Compute new vertical scroll position\n\t\t\t\tif (self.__enableScrollY) {\n\n\t\t\t\t\tscrollTop -= moveY * this.options.speedMultiplier;\n\t\t\t\t\tvar maxScrollTop = self.__maxScrollTop;\n\n\t\t\t\t\tif (scrollTop > maxScrollTop || scrollTop < 0) {\n\n\t\t\t\t\t\t// Slow down on the edges\n\t\t\t\t\t\tif (self.options.bouncing) {\n\n\t\t\t\t\t\t\tscrollTop += (moveY / 2 * this.options.speedMultiplier);\n\n\t\t\t\t\t\t\t// Support pull-to-refresh (only when only y is scrollable)\n\t\t\t\t\t\t\tif (!self.__enableScrollX && self.__refreshHeight != null) {\n\n\t\t\t\t\t\t\t\tif (!self.__refreshActive && scrollTop <= -self.__refreshHeight) {\n\n\t\t\t\t\t\t\t\t\tself.__refreshActive = true;\n\t\t\t\t\t\t\t\t\tif (self.__refreshActivate) {\n\t\t\t\t\t\t\t\t\t\tself.__refreshActivate();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t} else if (self.__refreshActive && scrollTop > -self.__refreshHeight) {\n\n\t\t\t\t\t\t\t\t\tself.__refreshActive = false;\n\t\t\t\t\t\t\t\t\tif (self.__refreshDeactivate) {\n\t\t\t\t\t\t\t\t\t\tself.__refreshDeactivate();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t} else if (scrollTop > maxScrollTop) {\n\n\t\t\t\t\t\t\tscrollTop = maxScrollTop;\n\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tscrollTop = 0;\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Keep list from growing infinitely (holding min 10, max 20 measure points)\n\t\t\t\tif (positions.length > 60) {\n\t\t\t\t\tpositions.splice(0, 30);\n\t\t\t\t}\n\n\t\t\t\t// Track scroll movement for decleration\n\t\t\t\tpositions.push(scrollLeft, scrollTop, timeStamp);\n\n\t\t\t\t// Sync scroll position\n\t\t\t\tself.__publish(scrollLeft, scrollTop, level);\n\n\t\t\t// Otherwise figure out whether we are switching into dragging mode now.\n\t\t\t} else {\n\n\t\t\t\tvar minimumTrackingForScroll = self.options.locking ? 3 : 0;\n\t\t\t\tvar minimumTrackingForDrag = 5;\n\n\t\t\t\tvar distanceX = Math.abs(currentTouchLeft - self.__initialTouchLeft);\n\t\t\t\tvar distanceY = Math.abs(currentTouchTop - self.__initialTouchTop);\n\n\t\t\t\tself.__enableScrollX = self.options.scrollingX && distanceX >= minimumTrackingForScroll;\n\t\t\t\tself.__enableScrollY = self.options.scrollingY && distanceY >= minimumTrackingForScroll;\n\n\t\t\t\tpositions.push(self.__scrollLeft, self.__scrollTop, timeStamp);\n\n\t\t\t\tself.__isDragging = (self.__enableScrollX || self.__enableScrollY) && (distanceX >= minimumTrackingForDrag || distanceY >= minimumTrackingForDrag);\n\t\t\t\tif (self.__isDragging) {\n\t\t\t\t\tself.__interruptedAnimation = false;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// Update last touch positions and time stamp for next event\n\t\t\tself.__lastTouchLeft = currentTouchLeft;\n\t\t\tself.__lastTouchTop = currentTouchTop;\n\t\t\tself.__lastTouchMove = timeStamp;\n\t\t\tself.__lastScale = scale;\n\n\t\t},\n\n\n\t\t/**\n\t\t * Touch end handler for scrolling support\n\t\t */\n\t\tdoTouchEnd: function(timeStamp) {\n\n\t\t\tif (timeStamp instanceof Date) {\n\t\t\t\ttimeStamp = timeStamp.valueOf();\n\t\t\t}\n\t\t\tif (typeof timeStamp !== \"number\") {\n\t\t\t\tthrow new Error(\"Invalid timestamp value: \" + timeStamp);\n\t\t\t}\n\n\t\t\tvar self = this;\n\n\t\t\t// Ignore event when tracking is not enabled (no touchstart event on element)\n\t\t\t// This is required as this listener ('touchmove') sits on the document and not on the element itself.\n\t\t\tif (!self.__isTracking) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Not touching anymore (when two finger hit the screen there are two touch end events)\n\t\t\tself.__isTracking = false;\n\n\t\t\t// Be sure to reset the dragging flag now. Here we also detect whether\n\t\t\t// the finger has moved fast enough to switch into a deceleration animation.\n\t\t\tif (self.__isDragging) {\n\n\t\t\t\t// Reset dragging flag\n\t\t\t\tself.__isDragging = false;\n\n\t\t\t\t// Start deceleration\n\t\t\t\t// Verify that the last move detected was in some relevant time frame\n\t\t\t\tif (self.__isSingleTouch && self.options.animating && (timeStamp - self.__lastTouchMove) <= 100) {\n\n\t\t\t\t\t// Then figure out what the scroll position was about 100ms ago\n\t\t\t\t\tvar positions = self.__positions;\n\t\t\t\t\tvar endPos = positions.length - 1;\n\t\t\t\t\tvar startPos = endPos;\n\n\t\t\t\t\t// Move pointer to position measured 100ms ago\n\t\t\t\t\tfor (var i = endPos; i > 0 && positions[i] > (self.__lastTouchMove - 100); i -= 3) {\n\t\t\t\t\t\tstartPos = i;\n\t\t\t\t\t}\n\n\t\t\t\t\t// If start and stop position is identical in a 100ms timeframe,\n\t\t\t\t\t// we cannot compute any useful deceleration.\n\t\t\t\t\tif (startPos !== endPos) {\n\n\t\t\t\t\t\t// Compute relative movement between these two points\n\t\t\t\t\t\tvar timeOffset = positions[endPos] - positions[startPos];\n\t\t\t\t\t\tvar movedLeft = self.__scrollLeft - positions[startPos - 2];\n\t\t\t\t\t\tvar movedTop = self.__scrollTop - positions[startPos - 1];\n\n\t\t\t\t\t\t// Based on 50ms compute the movement to apply for each render step\n\t\t\t\t\t\tself.__decelerationVelocityX = movedLeft / timeOffset * (1000 / 60);\n\t\t\t\t\t\tself.__decelerationVelocityY = movedTop / timeOffset * (1000 / 60);\n\n\t\t\t\t\t\t// How much velocity is required to start the deceleration\n\t\t\t\t\t\tvar minVelocityToStartDeceleration = self.options.paging || self.options.snapping ? 4 : 1;\n\n\t\t\t\t\t\t// Verify that we have enough velocity to start deceleration\n\t\t\t\t\t\tif (Math.abs(self.__decelerationVelocityX) > minVelocityToStartDeceleration || Math.abs(self.__decelerationVelocityY) > minVelocityToStartDeceleration) {\n\n\t\t\t\t\t\t\t// Deactivate pull-to-refresh when decelerating\n\t\t\t\t\t\t\tif (!self.__refreshActive) {\n\t\t\t\t\t\t\t\tself.__startDeceleration(timeStamp);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself.options.scrollingComplete();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.options.scrollingComplete();\n\t\t\t\t\t}\n\t\t\t\t} else if ((timeStamp - self.__lastTouchMove) > 100) {\n\t\t\t\t\tself.options.scrollingComplete();\n\t \t\t\t}\n\t\t\t}\n\n\t\t\t// If this was a slower move it is per default non decelerated, but this\n\t\t\t// still means that we want snap back to the bounds which is done here.\n\t\t\t// This is placed outside the condition above to improve edge case stability\n\t\t\t// e.g. touchend fired without enabled dragging. This should normally do not\n\t\t\t// have modified the scroll positions or even showed the scrollbars though.\n\t\t\tif (!self.__isDecelerating) {\n\n\t\t\t\tif (self.__refreshActive && self.__refreshStart) {\n\n\t\t\t\t\t// Use publish instead of scrollTo to allow scrolling to out of boundary position\n\t\t\t\t\t// We don't need to normalize scrollLeft, zoomLevel, etc. here because we only y-scrolling when pull-to-refresh is enabled\n\t\t\t\t\tself.__publish(self.__scrollLeft, -self.__refreshHeight, self.__zoomLevel, true);\n\n\t\t\t\t\tif (self.__refreshStart) {\n\t\t\t\t\t\tself.__refreshStart();\n\t\t\t\t\t}\n\n\t\t\t\t} else {\n\n\t\t\t\t\tif (self.__interruptedAnimation || self.__isDragging) {\n\t\t\t\t\t\tself.options.scrollingComplete();\n\t\t\t\t\t}\n\t\t\t\t\tself.scrollTo(self.__scrollLeft, self.__scrollTop, true, self.__zoomLevel);\n\n\t\t\t\t\t// Directly signalize deactivation (nothing todo on refresh?)\n\t\t\t\t\tif (self.__refreshActive) {\n\n\t\t\t\t\t\tself.__refreshActive = false;\n\t\t\t\t\t\tif (self.__refreshDeactivate) {\n\t\t\t\t\t\t\tself.__refreshDeactivate();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Fully cleanup list\n\t\t\tself.__positions.length = 0;\n\n\t\t},\n\n\n\n\t\t/*\n\t\t---------------------------------------------------------------------------\n\t\t\tPRIVATE API\n\t\t---------------------------------------------------------------------------\n\t\t*/\n\n\t\t/**\n\t\t * Applies the scroll position to the content element\n\t\t *\n\t\t * @param left {Number} Left scroll position\n\t\t * @param top {Number} Top scroll position\n\t\t * @param animate {Boolean?false} Whether animation should be used to move to the new coordinates\n\t\t */\n\t\t__publish: function(left, top, zoom, animate) {\n\n\t\t\tvar self = this;\n\n\t\t\t// Remember whether we had an animation, then we try to continue based on the current \"drive\" of the animation\n\t\t\tvar wasAnimating = self.__isAnimating;\n\t\t\tif (wasAnimating) {\n\t\t\t\tcore.effect.Animate.stop(wasAnimating);\n\t\t\t\tself.__isAnimating = false;\n\t\t\t}\n\n\t\t\tif (animate && self.options.animating) {\n\n\t\t\t\t// Keep scheduled positions for scrollBy/zoomBy functionality\n\t\t\t\tself.__scheduledLeft = left;\n\t\t\t\tself.__scheduledTop = top;\n\t\t\t\tself.__scheduledZoom = zoom;\n\n\t\t\t\tvar oldLeft = self.__scrollLeft;\n\t\t\t\tvar oldTop = self.__scrollTop;\n\t\t\t\tvar oldZoom = self.__zoomLevel;\n\n\t\t\t\tvar diffLeft = left - oldLeft;\n\t\t\t\tvar diffTop = top - oldTop;\n\t\t\t\tvar diffZoom = zoom - oldZoom;\n\n\t\t\t\tvar step = function(percent, now, render) {\n\n\t\t\t\t\tif (render) {\n\n\t\t\t\t\t\tself.__scrollLeft = oldLeft + (diffLeft * percent);\n\t\t\t\t\t\tself.__scrollTop = oldTop + (diffTop * percent);\n\t\t\t\t\t\tself.__zoomLevel = oldZoom + (diffZoom * percent);\n\n\t\t\t\t\t\t// Push values out\n\t\t\t\t\t\tif (self.__callback) {\n\t\t\t\t\t\t\tself.__callback(self.__scrollLeft, self.__scrollTop, self.__zoomLevel);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tvar verify = function(id) {\n\t\t\t\t\treturn self.__isAnimating === id;\n\t\t\t\t};\n\n\t\t\t\tvar completed = function(renderedFramesPerSecond, animationId, wasFinished) {\n\t\t\t\t\tif (animationId === self.__isAnimating) {\n\t\t\t\t\t\tself.__isAnimating = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (self.__didDecelerationComplete || wasFinished) {\n\t\t\t\t\t\tself.options.scrollingComplete();\n\t\t\t\t\t}\n\n\t\t\t\t\tif (self.options.zooming) {\n\t\t\t\t\t\tself.__computeScrollMax();\n\t\t\t\t\t\tif(self.__zoomComplete) {\n\t\t\t\t\t\t\tself.__zoomComplete();\n\t\t\t\t\t\t\tself.__zoomComplete = null;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\t// When continuing based on previous animation we choose an ease-out animation instead of ease-in-out\n\t\t\t\tself.__isAnimating = core.effect.Animate.start(step, verify, completed, self.options.animationDuration, wasAnimating ? easeOutCubic : easeInOutCubic);\n\n\t\t\t} else {\n\n\t\t\t\tself.__scheduledLeft = self.__scrollLeft = left;\n\t\t\t\tself.__scheduledTop = self.__scrollTop = top;\n\t\t\t\tself.__scheduledZoom = self.__zoomLevel = zoom;\n\n\t\t\t\t// Push values out\n\t\t\t\tif (self.__callback) {\n\t\t\t\t\tself.__callback(left, top, zoom);\n\t\t\t\t}\n\n\t\t\t\t// Fix max scroll ranges\n\t\t\t\tif (self.options.zooming) {\n\t\t\t\t\tself.__computeScrollMax();\n\t\t\t\t\tif(self.__zoomComplete) {\n\t\t\t\t\t\tself.__zoomComplete();\n\t\t\t\t\t\tself.__zoomComplete = null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\n\t\t/**\n\t\t * Recomputes scroll minimum values based on client dimensions and content dimensions.\n\t\t */\n\t\t__computeScrollMax: function(zoomLevel) {\n\n\t\t\tvar self = this;\n\n\t\t\tif (zoomLevel == null) {\n\t\t\t\tzoomLevel = self.__zoomLevel;\n\t\t\t}\n\n\t\t\tself.__maxScrollLeft = Math.max((self.__contentWidth * zoomLevel) - self.__clientWidth, 0);\n\t\t\tself.__maxScrollTop = Math.max((self.__contentHeight * zoomLevel) - self.__clientHeight, 0);\n\n\t\t},\n\n\n\n\t\t/*\n\t\t---------------------------------------------------------------------------\n\t\t\tANIMATION (DECELERATION) SUPPORT\n\t\t---------------------------------------------------------------------------\n\t\t*/\n\n\t\t/**\n\t\t * Called when a touch sequence end and the speed of the finger was high enough\n\t\t * to switch into deceleration mode.\n\t\t */\n\t\t__startDeceleration: function(timeStamp) {\n\n\t\t\tvar self = this;\n\n\t\t\tif (self.options.paging) {\n\n\t\t\t\tvar scrollLeft = Math.max(Math.min(self.__scrollLeft, self.__maxScrollLeft), 0);\n\t\t\t\tvar scrollTop = Math.max(Math.min(self.__scrollTop, self.__maxScrollTop), 0);\n\t\t\t\tvar clientWidth = self.__clientWidth;\n\t\t\t\tvar clientHeight = self.__clientHeight;\n\n\t\t\t\t// We limit deceleration not to the min/max values of the allowed range, but to the size of the visible client area.\n\t\t\t\t// Each page should have exactly the size of the client area.\n\t\t\t\tself.__minDecelerationScrollLeft = Math.floor(scrollLeft / clientWidth) * clientWidth;\n\t\t\t\tself.__minDecelerationScrollTop = Math.floor(scrollTop / clientHeight) * clientHeight;\n\t\t\t\tself.__maxDecelerationScrollLeft = Math.ceil(scrollLeft / clientWidth) * clientWidth;\n\t\t\t\tself.__maxDecelerationScrollTop = Math.ceil(scrollTop / clientHeight) * clientHeight;\n\n\t\t\t} else {\n\n\t\t\t\tself.__minDecelerationScrollLeft = 0;\n\t\t\t\tself.__minDecelerationScrollTop = 0;\n\t\t\t\tself.__maxDecelerationScrollLeft = self.__maxScrollLeft;\n\t\t\t\tself.__maxDecelerationScrollTop = self.__maxScrollTop;\n\n\t\t\t}\n\n\t\t\t// Wrap class method\n\t\t\tvar step = function(percent, now, render) {\n\t\t\t\tself.__stepThroughDeceleration(render);\n\t\t\t};\n\n\t\t\t// How much velocity is required to keep the deceleration running\n\t\t\tvar minVelocityToKeepDecelerating = self.options.snapping ? 4 : 0.001;\n\n\t\t\t// Detect whether it's still worth to continue animating steps\n\t\t\t// If we are already slow enough to not being user perceivable anymore, we stop the whole process here.\n\t\t\tvar verify = function() {\n\t\t\t\tvar shouldContinue = Math.abs(self.__decelerationVelocityX) >= minVelocityToKeepDecelerating || Math.abs(self.__decelerationVelocityY) >= minVelocityToKeepDecelerating;\n\t\t\t\tif (!shouldContinue) {\n\t\t\t\t\tself.__didDecelerationComplete = true;\n\t\t\t\t}\n\t\t\t\treturn shouldContinue;\n\t\t\t};\n\n\t\t\tvar completed = function(renderedFramesPerSecond, animationId, wasFinished) {\n\t\t\t\tself.__isDecelerating = false;\n\t\t\t\tif (self.__didDecelerationComplete) {\n\t\t\t\t\tself.options.scrollingComplete();\n\t\t\t\t}\n\n\t\t\t\t// Animate to grid when snapping is active, otherwise just fix out-of-boundary positions\n\t\t\t\tself.scrollTo(self.__scrollLeft, self.__scrollTop, self.options.snapping);\n\t\t\t};\n\n\t\t\t// Start animation and switch on flag\n\t\t\tself.__isDecelerating = core.effect.Animate.start(step, verify, completed);\n\n\t\t},\n\n\n\t\t/**\n\t\t * Called on every step of the animation\n\t\t *\n\t\t * @param inMemory {Boolean?false} Whether to not render the current step, but keep it in memory only. Used internally only!\n\t\t */\n\t\t__stepThroughDeceleration: function(render) {\n\n\t\t\tvar self = this;\n\n\n\t\t\t//\n\t\t\t// COMPUTE NEXT SCROLL POSITION\n\t\t\t//\n\n\t\t\t// Add deceleration to scroll position\n\t\t\tvar scrollLeft = self.__scrollLeft + self.__decelerationVelocityX;\n\t\t\tvar scrollTop = self.__scrollTop + self.__decelerationVelocityY;\n\n\n\t\t\t//\n\t\t\t// HARD LIMIT SCROLL POSITION FOR NON BOUNCING MODE\n\t\t\t//\n\n\t\t\tif (!self.options.bouncing) {\n\n\t\t\t\tvar scrollLeftFixed = Math.max(Math.min(self.__maxDecelerationScrollLeft, scrollLeft), self.__minDecelerationScrollLeft);\n\t\t\t\tif (scrollLeftFixed !== scrollLeft) {\n\t\t\t\t\tscrollLeft = scrollLeftFixed;\n\t\t\t\t\tself.__decelerationVelocityX = 0;\n\t\t\t\t}\n\n\t\t\t\tvar scrollTopFixed = Math.max(Math.min(self.__maxDecelerationScrollTop, scrollTop), self.__minDecelerationScrollTop);\n\t\t\t\tif (scrollTopFixed !== scrollTop) {\n\t\t\t\t\tscrollTop = scrollTopFixed;\n\t\t\t\t\tself.__decelerationVelocityY = 0;\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\t//\n\t\t\t// UPDATE SCROLL POSITION\n\t\t\t//\n\n\t\t\tif (render) {\n\n\t\t\t\tself.__publish(scrollLeft, scrollTop, self.__zoomLevel);\n\n\t\t\t} else {\n\n\t\t\t\tself.__scrollLeft = scrollLeft;\n\t\t\t\tself.__scrollTop = scrollTop;\n\n\t\t\t}\n\n\n\t\t\t//\n\t\t\t// SLOW DOWN\n\t\t\t//\n\n\t\t\t// Slow down velocity on every iteration\n\t\t\tif (!self.options.paging) {\n\n\t\t\t\t// This is the factor applied to every iteration of the animation\n\t\t\t\t// to slow down the process. This should emulate natural behavior where\n\t\t\t\t// objects slow down when the initiator of the movement is removed\n\t\t\t\tvar frictionFactor = 0.95;\n\n\t\t\t\tself.__decelerationVelocityX *= frictionFactor;\n\t\t\t\tself.__decelerationVelocityY *= frictionFactor;\n\n\t\t\t}\n\n\n\t\t\t//\n\t\t\t// BOUNCING SUPPORT\n\t\t\t//\n\n\t\t\tif (self.options.bouncing) {\n\n\t\t\t\tvar scrollOutsideX = 0;\n\t\t\t\tvar scrollOutsideY = 0;\n\n\t\t\t\t// This configures the amount of change applied to deceleration/acceleration when reaching boundaries\n\t\t\t\tvar penetrationDeceleration = self.options.penetrationDeceleration;\n\t\t\t\tvar penetrationAcceleration = self.options.penetrationAcceleration;\n\n\t\t\t\t// Check limits\n\t\t\t\tif (scrollLeft < self.__minDecelerationScrollLeft) {\n\t\t\t\t\tscrollOutsideX = self.__minDecelerationScrollLeft - scrollLeft;\n\t\t\t\t} else if (scrollLeft > self.__maxDecelerationScrollLeft) {\n\t\t\t\t\tscrollOutsideX = self.__maxDecelerationScrollLeft - scrollLeft;\n\t\t\t\t}\n\n\t\t\t\tif (scrollTop < self.__minDecelerationScrollTop) {\n\t\t\t\t\tscrollOutsideY = self.__minDecelerationScrollTop - scrollTop;\n\t\t\t\t} else if (scrollTop > self.__maxDecelerationScrollTop) {\n\t\t\t\t\tscrollOutsideY = self.__maxDecelerationScrollTop - scrollTop;\n\t\t\t\t}\n\n\t\t\t\t// Slow down until slow enough, then flip back to snap position\n\t\t\t\tif (scrollOutsideX !== 0) {\n\t\t\t\t\tif (scrollOutsideX * self.__decelerationVelocityX <= 0) {\n\t\t\t\t\t\tself.__decelerationVelocityX += scrollOutsideX * penetrationDeceleration;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.__decelerationVelocityX = scrollOutsideX * penetrationAcceleration;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (scrollOutsideY !== 0) {\n\t\t\t\t\tif (scrollOutsideY * self.__decelerationVelocityY <= 0) {\n\t\t\t\t\t\tself.__decelerationVelocityY += scrollOutsideY * penetrationDeceleration;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tself.__decelerationVelocityY = scrollOutsideY * penetrationAcceleration;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t// Copy over members to prototype\n\tfor (var key in members) {\n\t\tScroller.prototype[key] = members[key];\n\t}\n\n})();\nwindow.Scroller = module.exports = Scroller;\n\n\n// WEBPACK FOOTER //\n// ./src/Scroller.js"],"sourceRoot":""}